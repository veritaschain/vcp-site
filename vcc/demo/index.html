<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VCC Demo - VeritasChain Cloud</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        vcc: { 50: '#f0fdf4', 100: '#dcfce7', 200: '#bbf7d0', 300: '#86efac', 400: '#4ade80', 500: '#22c55e', 600: '#16a34a', 700: '#15803d', 800: '#166534', 900: '#14532d' }
                    }
                }
            }
        }
    </script>
    <style>
        .mono { font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; }
        .hash-text { font-size: 0.7rem; word-break: break-all; }
        .tree-node { transition: all 0.3s ease; }
        .tree-node.highlighted { background: #fef08a; transform: scale(1.1); }
        .tree-line { stroke: #9ca3af; stroke-width: 2; }
        .tree-line.highlighted { stroke: #22c55e; stroke-width: 3; }
        @keyframes pulse-red { 0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 50% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); } }
        .tamper-pulse { animation: pulse-red 1s infinite; }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 transition-colors">
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo, useRef } = React;

        // =============================================================================
        // Internationalization (i18n)
        // =============================================================================
        const translations = {
            en: {
                title: 'VCC Demo',
                subtitle: 'VeritasChain Cloud - Client-Side Demo',
                dashboard: 'Dashboard',
                events: 'Events',
                anchors: 'Anchors',
                verify: 'Verify',
                tamper: 'Tamper Demo',
                tree: 'Merkle Tree',
                simulator: 'Simulator',
                totalEvents: 'Total Events',
                anchorsCreated: 'Anchors Created',
                pendingEvents: 'Pending Events',
                quickActions: 'Quick Actions',
                createSingleEvent: '+ Create Single Event',
                createTradeFlow: 'ðŸ“Š Create Trade Flow (5 events)',
                createMerkleAnchor: 'ðŸ”— Create Merkle Anchor',
                pending: 'pending',
                recentEvents: 'Recent Events',
                noEventsYet: 'No events yet. Create some above!',
                type: 'Type',
                symbol: 'Symbol',
                hash: 'Hash',
                status: 'Status',
                time: 'Time',
                action: 'Action',
                verifyBtn: 'Verify',
                allEvents: 'All Events',
                eventHash: 'Event Hash',
                merkleRoot: 'Merkle Root',
                anchorRecords: 'Anchor Records',
                noAnchorsYet: 'No anchors yet. Create events and anchor them!',
                verifyEvent: 'Verify Event',
                verifySubtitle: "Select an anchored event to verify its Merkle proof independently.",
                selectEvent: 'Select Event',
                selectAnchored: '-- Select an anchored event --',
                verificationResult: 'Verification Result',
                verificationPassed: 'VERIFICATION PASSED',
                verificationFailed: 'VERIFICATION FAILED',
                certificateId: 'Certificate ID',
                verificationMethod: 'Verification Method',
                verifiedAt: 'Verified At',
                merkleProof: 'Merkle Proof',
                steps: 'steps',
                exportJson: 'Export JSON',
                exportCert: 'Export Certificate',
                showQr: 'Show QR',
                tamperDemo: 'Tamper Detection Demo',
                tamperSubtitle: 'See what happens when data is modified after anchoring.',
                selectEventToTamper: 'Select an event to tamper with:',
                originalData: 'Original Data',
                simulateTamper: 'âš ï¸ Simulate Tampering',
                tamperedData: 'Tampered Data (modified)',
                verifyTampered: 'ðŸ” Verify Tampered Event',
                tamperExplanation: 'Why Verification Failed',
                tamperReason1: '1. The original event hash was recorded in the Merkle tree',
                tamperReason2: '2. Tampering changed the data, producing a different hash',
                tamperReason3: '3. The new hash cannot reach the same Merkle root',
                tamperReason4: '4. This proves the data was modified after anchoring',
                resetTamper: 'Reset',
                treeVisualization: 'Merkle Tree Visualization',
                selectAnchorToVisualize: 'Select an anchor to visualize its Merkle tree:',
                selectAnchor: '-- Select an anchor --',
                treeStats: 'Tree Statistics',
                treeDepth: 'Tree Depth',
                leafCount: 'Leaf Count',
                clickToHighlight: 'Click any leaf node to see its audit path to the root.',
                auditPath: 'Audit Path',
                liveSimulator: 'Live Trading Simulator',
                simulatorSubtitle: 'Simulates real-time price feeds and automatic event generation.',
                startSimulator: 'â–¶ï¸ Start Simulator',
                stopSimulator: 'â¹ï¸ Stop Simulator',
                simulatorRunning: 'Simulator Running',
                simulatorStopped: 'Simulator Stopped',
                priceFeeds: 'Price Feeds',
                autoAnchor: 'Auto-anchor every 10 events',
                eventsGenerated: 'Events Generated',
                searchFilter: 'Search & Filter',
                searchPlaceholder: 'Search by trace ID, symbol...',
                filterByType: 'Filter by Type',
                allTypes: 'All Types',
                filterByStatus: 'Filter by Status',
                allStatuses: 'All Statuses',
                darkMode: 'Dark Mode',
                lightMode: 'Light Mode',
                language: 'Language',
                clearAllData: 'Clear All Data',
                footer1: 'VCC Demo - Client-Side Reference Implementation',
                footer2: 'This demo runs entirely in your browser using IndexedDB. No server required.',
                footer3: 'âš ï¸ This is NOT VC-Certified and does not constitute VSO endorsement.',
                verifyDontTrust: '"Verify, Don\'t Trust"',
                downloadPdf: 'ðŸ“„ Download PDF',
                close: 'Close',
                qrTitle: 'Certificate QR Code',
                qrSubtitle: 'Scan to verify this certificate',
            },
            ja: {
                title: 'VCC ãƒ‡ãƒ¢',
                subtitle: 'VeritasChain Cloud - ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ãƒ‡ãƒ¢',
                dashboard: 'ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰',
                events: 'ã‚¤ãƒ™ãƒ³ãƒˆ',
                anchors: 'ã‚¢ãƒ³ã‚«ãƒ¼',
                verify: 'æ¤œè¨¼',
                tamper: 'æ”¹ã–ã‚“æ¤œçŸ¥',
                tree: 'ãƒžãƒ¼ã‚¯ãƒ«ãƒ„ãƒªãƒ¼',
                simulator: 'ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿',
                totalEvents: 'ç·ã‚¤ãƒ™ãƒ³ãƒˆæ•°',
                anchorsCreated: 'ã‚¢ãƒ³ã‚«ãƒ¼æ•°',
                pendingEvents: 'ä¿ç•™ä¸­',
                quickActions: 'ã‚¯ã‚¤ãƒƒã‚¯ã‚¢ã‚¯ã‚·ãƒ§ãƒ³',
                createSingleEvent: '+ å˜ä¸€ã‚¤ãƒ™ãƒ³ãƒˆä½œæˆ',
                createTradeFlow: 'ðŸ“Š ãƒˆãƒ¬ãƒ¼ãƒ‰ãƒ•ãƒ­ãƒ¼ä½œæˆ (5ä»¶)',
                createMerkleAnchor: 'ðŸ”— ãƒžãƒ¼ã‚¯ãƒ«ã‚¢ãƒ³ã‚«ãƒ¼ä½œæˆ',
                pending: 'ä¿ç•™ä¸­',
                recentEvents: 'æœ€è¿‘ã®ã‚¤ãƒ™ãƒ³ãƒˆ',
                noEventsYet: 'ã‚¤ãƒ™ãƒ³ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚ä¸Šã®ãƒœã‚¿ãƒ³ã§ä½œæˆã—ã¦ãã ã•ã„ã€‚',
                type: 'ã‚¿ã‚¤ãƒ—',
                symbol: 'ã‚·ãƒ³ãƒœãƒ«',
                hash: 'ãƒãƒƒã‚·ãƒ¥',
                status: 'ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹',
                time: 'æ™‚åˆ»',
                action: 'ã‚¢ã‚¯ã‚·ãƒ§ãƒ³',
                verifyBtn: 'æ¤œè¨¼',
                allEvents: 'å…¨ã‚¤ãƒ™ãƒ³ãƒˆ',
                eventHash: 'ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒƒã‚·ãƒ¥',
                merkleRoot: 'ãƒžãƒ¼ã‚¯ãƒ«ãƒ«ãƒ¼ãƒˆ',
                anchorRecords: 'ã‚¢ãƒ³ã‚«ãƒ¼è¨˜éŒ²',
                noAnchorsYet: 'ã‚¢ãƒ³ã‚«ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã—ã¦ã‚¢ãƒ³ã‚«ãƒ¼åŒ–ã—ã¦ãã ã•ã„ã€‚',
                verifyEvent: 'ã‚¤ãƒ™ãƒ³ãƒˆæ¤œè¨¼',
                verifySubtitle: 'ã‚¢ãƒ³ã‚«ãƒ¼åŒ–ã•ã‚ŒãŸã‚¤ãƒ™ãƒ³ãƒˆã‚’é¸æŠžã—ã€ãƒžãƒ¼ã‚¯ãƒ«è¨¼æ˜Žã‚’ç‹¬ç«‹ã—ã¦æ¤œè¨¼ã—ã¾ã™ã€‚',
                selectEvent: 'ã‚¤ãƒ™ãƒ³ãƒˆé¸æŠž',
                selectAnchored: '-- ã‚¢ãƒ³ã‚«ãƒ¼æ¸ˆã¿ã‚¤ãƒ™ãƒ³ãƒˆã‚’é¸æŠž --',
                verificationResult: 'æ¤œè¨¼çµæžœ',
                verificationPassed: 'æ¤œè¨¼æˆåŠŸ',
                verificationFailed: 'æ¤œè¨¼å¤±æ•—',
                certificateId: 'è¨¼æ˜Žæ›¸ID',
                verificationMethod: 'æ¤œè¨¼æ–¹å¼',
                verifiedAt: 'æ¤œè¨¼æ—¥æ™‚',
                merkleProof: 'ãƒžãƒ¼ã‚¯ãƒ«è¨¼æ˜Ž',
                steps: 'ã‚¹ãƒ†ãƒƒãƒ—',
                exportJson: 'JSONå‡ºåŠ›',
                exportCert: 'è¨¼æ˜Žæ›¸å‡ºåŠ›',
                showQr: 'QRè¡¨ç¤º',
                tamperDemo: 'æ”¹ã–ã‚“æ¤œçŸ¥ãƒ‡ãƒ¢',
                tamperSubtitle: 'ã‚¢ãƒ³ã‚«ãƒ¼å¾Œã«ãƒ‡ãƒ¼ã‚¿ãŒå¤‰æ›´ã•ã‚Œã‚‹ã¨ä½•ãŒèµ·ã“ã‚‹ã‹ç¢ºèªã§ãã¾ã™ã€‚',
                selectEventToTamper: 'æ”¹ã–ã‚“ã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã‚’é¸æŠž:',
                originalData: 'å…ƒãƒ‡ãƒ¼ã‚¿',
                simulateTamper: 'âš ï¸ æ”¹ã–ã‚“ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ',
                tamperedData: 'æ”¹ã–ã‚“ãƒ‡ãƒ¼ã‚¿ï¼ˆå¤‰æ›´æ¸ˆã¿ï¼‰',
                verifyTampered: 'ðŸ” æ”¹ã–ã‚“ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œè¨¼',
                tamperExplanation: 'æ¤œè¨¼ãŒå¤±æ•—ã—ãŸç†ç”±',
                tamperReason1: '1. å…ƒã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒƒã‚·ãƒ¥ãŒãƒžãƒ¼ã‚¯ãƒ«ãƒ„ãƒªãƒ¼ã«è¨˜éŒ²ã•ã‚Œã¦ã„ã¾ã™',
                tamperReason2: '2. æ”¹ã–ã‚“ã«ã‚ˆã‚Šãƒ‡ãƒ¼ã‚¿ãŒå¤‰æ›´ã•ã‚Œã€ç•°ãªã‚‹ãƒãƒƒã‚·ãƒ¥ãŒç”Ÿæˆã•ã‚Œã¾ã—ãŸ',
                tamperReason3: '3. æ–°ã—ã„ãƒãƒƒã‚·ãƒ¥ã§ã¯åŒã˜ãƒžãƒ¼ã‚¯ãƒ«ãƒ«ãƒ¼ãƒˆã«åˆ°é”ã§ãã¾ã›ã‚“',
                tamperReason4: '4. ã“ã‚Œã¯ãƒ‡ãƒ¼ã‚¿ãŒã‚¢ãƒ³ã‚«ãƒ¼å¾Œã«å¤‰æ›´ã•ã‚ŒãŸã“ã¨ã‚’è¨¼æ˜Žã—ã¦ã„ã¾ã™',
                resetTamper: 'ãƒªã‚»ãƒƒãƒˆ',
                treeVisualization: 'ãƒžãƒ¼ã‚¯ãƒ«ãƒ„ãƒªãƒ¼å¯è¦–åŒ–',
                selectAnchorToVisualize: 'å¯è¦–åŒ–ã™ã‚‹ã‚¢ãƒ³ã‚«ãƒ¼ã‚’é¸æŠž:',
                selectAnchor: '-- ã‚¢ãƒ³ã‚«ãƒ¼ã‚’é¸æŠž --',
                treeStats: 'ãƒ„ãƒªãƒ¼çµ±è¨ˆ',
                treeDepth: 'ãƒ„ãƒªãƒ¼æ·±åº¦',
                leafCount: 'ãƒªãƒ¼ãƒ•æ•°',
                clickToHighlight: 'ãƒªãƒ¼ãƒ•ãƒŽãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€ãƒ«ãƒ¼ãƒˆã¸ã®ç›£æŸ»ãƒ‘ã‚¹ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚',
                auditPath: 'ç›£æŸ»ãƒ‘ã‚¹',
                liveSimulator: 'ãƒ©ã‚¤ãƒ–å–å¼•ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿',
                simulatorSubtitle: 'ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ä¾¡æ ¼ãƒ•ã‚£ãƒ¼ãƒ‰ã¨è‡ªå‹•ã‚¤ãƒ™ãƒ³ãƒˆç”Ÿæˆã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ã¾ã™ã€‚',
                startSimulator: 'â–¶ï¸ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿é–‹å§‹',
                stopSimulator: 'â¹ï¸ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿åœæ­¢',
                simulatorRunning: 'ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿å®Ÿè¡Œä¸­',
                simulatorStopped: 'ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿åœæ­¢ä¸­',
                priceFeeds: 'ä¾¡æ ¼ãƒ•ã‚£ãƒ¼ãƒ‰',
                autoAnchor: '10ã‚¤ãƒ™ãƒ³ãƒˆã”ã¨ã«è‡ªå‹•ã‚¢ãƒ³ã‚«ãƒ¼',
                eventsGenerated: 'ç”Ÿæˆã‚¤ãƒ™ãƒ³ãƒˆæ•°',
                searchFilter: 'æ¤œç´¢ãƒ»ãƒ•ã‚£ãƒ«ã‚¿',
                searchPlaceholder: 'ãƒˆãƒ¬ãƒ¼ã‚¹IDã€ã‚·ãƒ³ãƒœãƒ«ã§æ¤œç´¢...',
                filterByType: 'ã‚¿ã‚¤ãƒ—ã§ãƒ•ã‚£ãƒ«ã‚¿',
                allTypes: 'å…¨ã‚¿ã‚¤ãƒ—',
                filterByStatus: 'ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã§ãƒ•ã‚£ãƒ«ã‚¿',
                allStatuses: 'å…¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹',
                darkMode: 'ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰',
                lightMode: 'ãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰',
                language: 'è¨€èªž',
                clearAllData: 'å…¨ãƒ‡ãƒ¼ã‚¿å‰Šé™¤',
                footer1: 'VCC ãƒ‡ãƒ¢ - ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹å®Ÿè£…',
                footer2: 'ã“ã®ãƒ‡ãƒ¢ã¯IndexedDBã‚’ä½¿ç”¨ã—ã¦ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§å®Œå…¨ã«å‹•ä½œã—ã¾ã™ã€‚ã‚µãƒ¼ãƒãƒ¼ä¸è¦ã€‚',
                footer3: 'âš ï¸ ã“ã‚Œã¯VC-Certifiedèªè¨¼ã‚’å—ã‘ã¦ãŠã‚‰ãšã€VSOã®æŽ¨å¥¨ã‚’æ„å‘³ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚',
                verifyDontTrust: 'ã€Œä¿¡é ¼ã™ã‚‹ãªã€æ¤œè¨¼ã›ã‚ˆã€',
                downloadPdf: 'ðŸ“„ PDFå‡ºåŠ›',
                close: 'é–‰ã˜ã‚‹',
                qrTitle: 'è¨¼æ˜Žæ›¸QRã‚³ãƒ¼ãƒ‰',
                qrSubtitle: 'ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦è¨¼æ˜Žæ›¸ã‚’æ¤œè¨¼',
            },
            zh: {
                title: 'VCC æ¼”ç¤º',
                subtitle: 'VeritasChain Cloud - å®¢æˆ·ç«¯æ¼”ç¤º',
                dashboard: 'ä»ªè¡¨æ¿',
                events: 'äº‹ä»¶',
                anchors: 'é”šç‚¹',
                verify: 'éªŒè¯',
                tamper: 'ç¯¡æ”¹æ£€æµ‹',
                tree: 'é»˜å…‹å°”æ ‘',
                simulator: 'æ¨¡æ‹Ÿå™¨',
                totalEvents: 'æ€»äº‹ä»¶æ•°',
                anchorsCreated: 'é”šç‚¹æ•°',
                pendingEvents: 'å¾…å¤„ç†',
                quickActions: 'å¿«æ·æ“ä½œ',
                createSingleEvent: '+ åˆ›å»ºå•ä¸ªäº‹ä»¶',
                createTradeFlow: 'ðŸ“Š åˆ›å»ºäº¤æ˜“æµç¨‹ (5ä¸ªäº‹ä»¶)',
                createMerkleAnchor: 'ðŸ”— åˆ›å»ºé»˜å…‹å°”é”šç‚¹',
                pending: 'å¾…å¤„ç†',
                recentEvents: 'æœ€è¿‘äº‹ä»¶',
                noEventsYet: 'æš‚æ— äº‹ä»¶ã€‚è¯·ä½¿ç”¨ä¸Šæ–¹æŒ‰é’®åˆ›å»ºã€‚',
                type: 'ç±»åž‹',
                symbol: 'ç¬¦å·',
                hash: 'å“ˆå¸Œ',
                status: 'çŠ¶æ€',
                time: 'æ—¶é—´',
                action: 'æ“ä½œ',
                verifyBtn: 'éªŒè¯',
                allEvents: 'æ‰€æœ‰äº‹ä»¶',
                eventHash: 'äº‹ä»¶å“ˆå¸Œ',
                merkleRoot: 'é»˜å…‹å°”æ ¹',
                anchorRecords: 'é”šç‚¹è®°å½•',
                noAnchorsYet: 'æš‚æ— é”šç‚¹ã€‚è¯·åˆ›å»ºäº‹ä»¶å¹¶é”šå®šã€‚',
                verifyEvent: 'äº‹ä»¶éªŒè¯',
                verifySubtitle: 'é€‰æ‹©å·²é”šå®šçš„äº‹ä»¶ï¼Œç‹¬ç«‹éªŒè¯å…¶é»˜å…‹å°”è¯æ˜Žã€‚',
                selectEvent: 'é€‰æ‹©äº‹ä»¶',
                selectAnchored: '-- é€‰æ‹©å·²é”šå®šäº‹ä»¶ --',
                verificationResult: 'éªŒè¯ç»“æžœ',
                verificationPassed: 'éªŒè¯é€šè¿‡',
                verificationFailed: 'éªŒè¯å¤±è´¥',
                certificateId: 'è¯ä¹¦ID',
                verificationMethod: 'éªŒè¯æ–¹æ³•',
                verifiedAt: 'éªŒè¯æ—¶é—´',
                merkleProof: 'é»˜å…‹å°”è¯æ˜Ž',
                steps: 'æ­¥éª¤',
                exportJson: 'å¯¼å‡ºJSON',
                exportCert: 'å¯¼å‡ºè¯ä¹¦',
                showQr: 'æ˜¾ç¤ºäºŒç»´ç ',
                tamperDemo: 'ç¯¡æ”¹æ£€æµ‹æ¼”ç¤º',
                tamperSubtitle: 'æŸ¥çœ‹é”šå®šåŽæ•°æ®è¢«ä¿®æ”¹æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚',
                selectEventToTamper: 'é€‰æ‹©è¦ç¯¡æ”¹çš„äº‹ä»¶:',
                originalData: 'åŽŸå§‹æ•°æ®',
                simulateTamper: 'âš ï¸ æ¨¡æ‹Ÿç¯¡æ”¹',
                tamperedData: 'å·²ç¯¡æ”¹æ•°æ®ï¼ˆå·²ä¿®æ”¹ï¼‰',
                verifyTampered: 'ðŸ” éªŒè¯å·²ç¯¡æ”¹äº‹ä»¶',
                tamperExplanation: 'éªŒè¯å¤±è´¥çš„åŽŸå› ',
                tamperReason1: '1. åŽŸå§‹äº‹ä»¶å“ˆå¸Œå·²è®°å½•åœ¨é»˜å…‹å°”æ ‘ä¸­',
                tamperReason2: '2. ç¯¡æ”¹æ›´æ”¹äº†æ•°æ®ï¼Œäº§ç”Ÿäº†ä¸åŒçš„å“ˆå¸Œ',
                tamperReason3: '3. æ–°å“ˆå¸Œæ— æ³•åˆ°è¾¾ç›¸åŒçš„é»˜å…‹å°”æ ¹',
                tamperReason4: '4. è¿™è¯æ˜Žæ•°æ®åœ¨é”šå®šåŽè¢«ä¿®æ”¹',
                resetTamper: 'é‡ç½®',
                treeVisualization: 'é»˜å…‹å°”æ ‘å¯è§†åŒ–',
                selectAnchorToVisualize: 'é€‰æ‹©è¦å¯è§†åŒ–çš„é”šç‚¹:',
                selectAnchor: '-- é€‰æ‹©é”šç‚¹ --',
                treeStats: 'æ ‘ç»Ÿè®¡',
                treeDepth: 'æ ‘æ·±åº¦',
                leafCount: 'å¶èŠ‚ç‚¹æ•°',
                clickToHighlight: 'ç‚¹å‡»ä»»æ„å¶èŠ‚ç‚¹æŸ¥çœ‹å…¶åˆ°æ ¹çš„å®¡è®¡è·¯å¾„ã€‚',
                auditPath: 'å®¡è®¡è·¯å¾„',
                liveSimulator: 'å®žæ—¶äº¤æ˜“æ¨¡æ‹Ÿå™¨',
                simulatorSubtitle: 'æ¨¡æ‹Ÿå®žæ—¶ä»·æ ¼é¦ˆé€å’Œè‡ªåŠ¨äº‹ä»¶ç”Ÿæˆã€‚',
                startSimulator: 'â–¶ï¸ å¯åŠ¨æ¨¡æ‹Ÿå™¨',
                stopSimulator: 'â¹ï¸ åœæ­¢æ¨¡æ‹Ÿå™¨',
                simulatorRunning: 'æ¨¡æ‹Ÿå™¨è¿è¡Œä¸­',
                simulatorStopped: 'æ¨¡æ‹Ÿå™¨å·²åœæ­¢',
                priceFeeds: 'ä»·æ ¼é¦ˆé€',
                autoAnchor: 'æ¯10ä¸ªäº‹ä»¶è‡ªåŠ¨é”šå®š',
                eventsGenerated: 'å·²ç”Ÿæˆäº‹ä»¶',
                searchFilter: 'æœç´¢å’Œç­›é€‰',
                searchPlaceholder: 'æŒ‰è·Ÿè¸ªIDã€ç¬¦å·æœç´¢...',
                filterByType: 'æŒ‰ç±»åž‹ç­›é€‰',
                allTypes: 'æ‰€æœ‰ç±»åž‹',
                filterByStatus: 'æŒ‰çŠ¶æ€ç­›é€‰',
                allStatuses: 'æ‰€æœ‰çŠ¶æ€',
                darkMode: 'æ·±è‰²æ¨¡å¼',
                lightMode: 'æµ…è‰²æ¨¡å¼',
                language: 'è¯­è¨€',
                clearAllData: 'æ¸…é™¤æ‰€æœ‰æ•°æ®',
                footer1: 'VCCæ¼”ç¤º - å®¢æˆ·ç«¯å‚è€ƒå®žçŽ°',
                footer2: 'æ­¤æ¼”ç¤ºå®Œå…¨åœ¨æµè§ˆå™¨ä¸­ä½¿ç”¨IndexedDBè¿è¡Œã€‚æ— éœ€æœåŠ¡å™¨ã€‚',
                footer3: 'âš ï¸ è¿™ä¸æ˜¯VC-Certifiedè®¤è¯ï¼Œä¸ä»£è¡¨VSOçš„è®¤å¯ã€‚',
                verifyDontTrust: '"éªŒè¯ï¼Œè€Œéžä¿¡ä»»"',
                downloadPdf: 'ðŸ“„ ä¸‹è½½PDF',
                close: 'å…³é—­',
                qrTitle: 'è¯ä¹¦äºŒç»´ç ',
                qrSubtitle: 'æ‰«æä»¥éªŒè¯æ­¤è¯ä¹¦',
            },
            es: {
                title: 'VCC Demo',
                subtitle: 'VeritasChain Cloud - Demo del Cliente',
                dashboard: 'Panel',
                events: 'Eventos',
                anchors: 'Anclas',
                verify: 'Verificar',
                tamper: 'Demo ManipulaciÃ³n',
                tree: 'Ãrbol Merkle',
                simulator: 'Simulador',
                totalEvents: 'Total de Eventos',
                anchorsCreated: 'Anclas Creadas',
                pendingEvents: 'Eventos Pendientes',
                quickActions: 'Acciones RÃ¡pidas',
                createSingleEvent: '+ Crear Evento Individual',
                createTradeFlow: 'ðŸ“Š Crear Flujo de Trading (5 eventos)',
                createMerkleAnchor: 'ðŸ”— Crear Ancla Merkle',
                pending: 'pendiente',
                recentEvents: 'Eventos Recientes',
                noEventsYet: 'Sin eventos aÃºn. Â¡Crea algunos arriba!',
                type: 'Tipo',
                symbol: 'SÃ­mbolo',
                hash: 'Hash',
                status: 'Estado',
                time: 'Hora',
                action: 'AcciÃ³n',
                verifyBtn: 'Verificar',
                allEvents: 'Todos los Eventos',
                eventHash: 'Hash del Evento',
                merkleRoot: 'RaÃ­z Merkle',
                anchorRecords: 'Registros de Anclas',
                noAnchorsYet: 'Sin anclas aÃºn. Â¡Crea eventos y anclarlos!',
                verifyEvent: 'Verificar Evento',
                verifySubtitle: 'Selecciona un evento anclado para verificar su prueba Merkle independientemente.',
                selectEvent: 'Seleccionar Evento',
                selectAnchored: '-- Seleccionar evento anclado --',
                verificationResult: 'Resultado de VerificaciÃ³n',
                verificationPassed: 'VERIFICACIÃ“N EXITOSA',
                verificationFailed: 'VERIFICACIÃ“N FALLIDA',
                certificateId: 'ID del Certificado',
                verificationMethod: 'MÃ©todo de VerificaciÃ³n',
                verifiedAt: 'Verificado En',
                merkleProof: 'Prueba Merkle',
                steps: 'pasos',
                exportJson: 'Exportar JSON',
                exportCert: 'Exportar Certificado',
                showQr: 'Mostrar QR',
                tamperDemo: 'Demo de DetecciÃ³n de ManipulaciÃ³n',
                tamperSubtitle: 'Ve quÃ© sucede cuando los datos se modifican despuÃ©s del anclaje.',
                selectEventToTamper: 'Selecciona un evento para manipular:',
                originalData: 'Datos Originales',
                simulateTamper: 'âš ï¸ Simular ManipulaciÃ³n',
                tamperedData: 'Datos Manipulados (modificados)',
                verifyTampered: 'ðŸ” Verificar Evento Manipulado',
                tamperExplanation: 'Por QuÃ© FallÃ³ la VerificaciÃ³n',
                tamperReason1: '1. El hash del evento original fue registrado en el Ã¡rbol Merkle',
                tamperReason2: '2. La manipulaciÃ³n cambiÃ³ los datos, produciendo un hash diferente',
                tamperReason3: '3. El nuevo hash no puede alcanzar la misma raÃ­z Merkle',
                tamperReason4: '4. Esto prueba que los datos fueron modificados despuÃ©s del anclaje',
                resetTamper: 'Reiniciar',
                treeVisualization: 'VisualizaciÃ³n del Ãrbol Merkle',
                selectAnchorToVisualize: 'Selecciona un ancla para visualizar:',
                selectAnchor: '-- Seleccionar ancla --',
                treeStats: 'EstadÃ­sticas del Ãrbol',
                treeDepth: 'Profundidad',
                leafCount: 'Cantidad de Hojas',
                clickToHighlight: 'Haz clic en cualquier nodo hoja para ver su ruta de auditorÃ­a hasta la raÃ­z.',
                auditPath: 'Ruta de AuditorÃ­a',
                liveSimulator: 'Simulador de Trading en Vivo',
                simulatorSubtitle: 'Simula feeds de precios en tiempo real y generaciÃ³n automÃ¡tica de eventos.',
                startSimulator: 'â–¶ï¸ Iniciar Simulador',
                stopSimulator: 'â¹ï¸ Detener Simulador',
                simulatorRunning: 'Simulador EjecutÃ¡ndose',
                simulatorStopped: 'Simulador Detenido',
                priceFeeds: 'Feeds de Precios',
                autoAnchor: 'Auto-anclar cada 10 eventos',
                eventsGenerated: 'Eventos Generados',
                searchFilter: 'Buscar y Filtrar',
                searchPlaceholder: 'Buscar por trace ID, sÃ­mbolo...',
                filterByType: 'Filtrar por Tipo',
                allTypes: 'Todos los Tipos',
                filterByStatus: 'Filtrar por Estado',
                allStatuses: 'Todos los Estados',
                darkMode: 'Modo Oscuro',
                lightMode: 'Modo Claro',
                language: 'Idioma',
                clearAllData: 'Borrar Todos los Datos',
                footer1: 'VCC Demo - ImplementaciÃ³n de Referencia del Cliente',
                footer2: 'Este demo se ejecuta completamente en tu navegador usando IndexedDB. Sin servidor.',
                footer3: 'âš ï¸ Esto NO estÃ¡ VC-Certified y no constituye respaldo de VSO.',
                verifyDontTrust: '"Verifica, No ConfÃ­es"',
                downloadPdf: 'ðŸ“„ Descargar PDF',
                close: 'Cerrar',
                qrTitle: 'CÃ³digo QR del Certificado',
                qrSubtitle: 'Escanea para verificar este certificado',
            }
        };

        const useTranslation = (lang) => {
            return useCallback((key) => translations[lang]?.[key] || translations.en[key] || key, [lang]);
        };

        // =============================================================================
        // VCP v1.1 Core Implementation
        // =============================================================================

        const generateUUIDv7 = () => {
            const now = BigInt(Date.now());
            const timeHex = now.toString(16).padStart(12, '0');
            const randomBytes = new Uint8Array(10);
            crypto.getRandomValues(randomBytes);
            const randomHex = Array.from(randomBytes).map(b => b.toString(16).padStart(2, '0')).join('');
            return `${timeHex.slice(0,8)}-${timeHex.slice(8,12)}-7${randomHex.slice(0,3)}-${(0x80 | (parseInt(randomHex.slice(3,5), 16) & 0x3f)).toString(16)}${randomHex.slice(5,7)}-${randomHex.slice(7,19)}`;
        };

        const sha256 = async (data) => {
            const encoder = new TextEncoder();
            const dataBuffer = encoder.encode(typeof data === 'string' ? data : JSON.stringify(data));
            const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
            return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
        };

        const merkleHashLeaf = async (data) => {
            const prefix = new Uint8Array([0x00]);
            const dataBytes = new TextEncoder().encode(data);
            const combined = new Uint8Array(prefix.length + dataBytes.length);
            combined.set(prefix);
            combined.set(dataBytes, prefix.length);
            const hash = await crypto.subtle.digest('SHA-256', combined);
            return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
        };

        const merkleHashNode = async (left, right) => {
            const prefix = new Uint8Array([0x01]);
            const leftBytes = new Uint8Array(left.match(/.{2}/g).map(h => parseInt(h, 16)));
            const rightBytes = new Uint8Array(right.match(/.{2}/g).map(h => parseInt(h, 16)));
            const combined = new Uint8Array(prefix.length + leftBytes.length + rightBytes.length);
            combined.set(prefix);
            combined.set(leftBytes, prefix.length);
            combined.set(rightBytes, prefix.length + leftBytes.length);
            const hash = await crypto.subtle.digest('SHA-256', combined);
            return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
        };

        const buildMerkleTree = async (hashes) => {
            if (hashes.length === 0) return [];
            let leaves = await Promise.all(hashes.map(h => merkleHashLeaf(h)));
            const tree = [leaves];
            while (leaves.length > 1) {
                const nextLevel = [];
                for (let i = 0; i < leaves.length; i += 2) {
                    if (i + 1 < leaves.length) {
                        nextLevel.push(await merkleHashNode(leaves[i], leaves[i + 1]));
                    } else {
                        nextLevel.push(leaves[i]);
                    }
                }
                tree.push(nextLevel);
                leaves = nextLevel;
            }
            return tree;
        };

        const getMerkleRoot = (tree) => tree.length > 0 ? tree[tree.length - 1][0] : null;

        const generateAuditPath = (tree, leafIndex) => {
            const path = [];
            let idx = leafIndex;
            for (let level = 0; level < tree.length - 1; level++) {
                const isRight = idx % 2 === 1;
                const siblingIdx = isRight ? idx - 1 : idx + 1;
                if (siblingIdx < tree[level].length) {
                    path.push({ hash: tree[level][siblingIdx], position: isRight ? 'left' : 'right', level, siblingIdx });
                }
                idx = Math.floor(idx / 2);
            }
            return path;
        };

        const verifyMerkleProof = async (eventHash, merkleRoot, auditPath) => {
            let currentHash = await merkleHashLeaf(eventHash);
            for (const step of auditPath) {
                if (step.position === 'left') {
                    currentHash = await merkleHashNode(step.hash, currentHash);
                } else {
                    currentHash = await merkleHashNode(currentHash, step.hash);
                }
            }
            return currentHash === merkleRoot;
        };

        const EVENT_TYPES = {
            SIG: { code: 1, name: 'Signal Generated', color: 'blue' },
            ORD: { code: 2, name: 'Order Submitted', color: 'yellow' },
            ACK: { code: 3, name: 'Order Acknowledged', color: 'green' },
            REJ: { code: 4, name: 'Order Rejected', color: 'red' },
            EXE: { code: 5, name: 'Execution', color: 'purple' },
            CXL: { code: 6, name: 'Cancellation', color: 'orange' },
            CLS: { code: 10, name: 'Position Closed', color: 'gray' }
        };

        // =============================================================================
        // IndexedDB Storage
        // =============================================================================

        const DB_NAME = 'VCCDemo';
        const DB_VERSION = 1;

        const openDB = () => new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve(request.result);
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('events')) {
                    const eventStore = db.createObjectStore('events', { keyPath: 'event_id' });
                    eventStore.createIndex('trace_id', 'trace_id', { unique: false });
                    eventStore.createIndex('account_id', 'account_id', { unique: false });
                    eventStore.createIndex('timestamp', 'timestamp_int', { unique: false });
                }
                if (!db.objectStoreNames.contains('anchors')) {
                    db.createObjectStore('anchors', { keyPath: 'anchor_id' });
                }
            };
        });

        const dbOperation = async (storeName, mode, operation) => {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, mode);
                const store = tx.objectStore(storeName);
                const request = operation(store);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        };

        // =============================================================================
        // VCC Service
        // =============================================================================

        const VCCService = {
            async createEvent(eventType, symbol, accountId, payload = {}) {
                const eventId = generateUUIDv7();
                const traceId = payload.trace_id || generateUUIDv7();
                const now = Date.now();
                const event = {
                    event_id: eventId,
                    trace_id: traceId,
                    timestamp_int: now * 1000000,
                    timestamp_iso: new Date(now).toISOString(),
                    event_type: eventType,
                    event_type_code: EVENT_TYPES[eventType]?.code || 0,
                    symbol: symbol,
                    venue_id: 'VCC-DEMO',
                    account_id: accountId,
                    payload: payload,
                    anchor_status: 'PENDING',
                    created_at: new Date().toISOString()
                };
                const hashInput = {
                    event_id: event.event_id,
                    trace_id: event.trace_id,
                    timestamp_int: event.timestamp_int,
                    event_type: event.event_type,
                    symbol: event.symbol,
                    venue_id: event.venue_id,
                    account_id: event.account_id,
                    payload: event.payload
                };
                event.event_hash = await sha256(hashInput);
                await dbOperation('events', 'readwrite', store => store.add(event));
                return event;
            },

            async getEvents(limit = 500) {
                const db = await openDB();
                return new Promise((resolve) => {
                    const tx = db.transaction('events', 'readonly');
                    const store = tx.objectStore('events');
                    const events = [];
                    store.openCursor(null, 'prev').onsuccess = (e) => {
                        const cursor = e.target.result;
                        if (cursor && events.length < limit) {
                            events.push(cursor.value);
                            cursor.continue();
                        } else {
                            resolve(events);
                        }
                    };
                });
            },

            async getPendingEvents() {
                const events = await this.getEvents(500);
                return events.filter(e => e.anchor_status === 'PENDING');
            },

            async createAnchor() {
                const pending = await this.getPendingEvents();
                if (pending.length === 0) return null;
                pending.sort((a, b) => a.timestamp_int - b.timestamp_int);
                const eventHashes = pending.map(e => e.event_hash);
                const tree = await buildMerkleTree(eventHashes);
                const merkleRoot = getMerkleRoot(tree);
                const anchorId = generateUUIDv7();
                const anchor = {
                    anchor_id: anchorId,
                    merkle_root: merkleRoot,
                    timestamp_iso: new Date().toISOString(),
                    anchor_type: 'CLIENT_DEMO',
                    anchor_identifier: 'browser-indexeddb',
                    event_count: pending.length,
                    event_ids: pending.map(e => e.event_id),
                    event_hashes: eventHashes,
                    status: 'ANCHORED',
                    tree: tree
                };
                await dbOperation('anchors', 'readwrite', store => store.add(anchor));
                const db = await openDB();
                const tx = db.transaction('events', 'readwrite');
                const store = tx.objectStore('events');
                for (let i = 0; i < pending.length; i++) {
                    pending[i].anchor_status = 'ANCHORED';
                    pending[i].anchor_reference = anchorId;
                    pending[i].merkle_root = merkleRoot;
                    pending[i].merkle_index = i;
                    store.put(pending[i]);
                }
                return anchor;
            },

            async getAnchors() {
                const db = await openDB();
                return new Promise((resolve) => {
                    const tx = db.transaction('anchors', 'readonly');
                    const store = tx.objectStore('anchors');
                    const anchors = [];
                    store.openCursor(null, 'prev').onsuccess = (e) => {
                        const cursor = e.target.result;
                        if (cursor) {
                            anchors.push(cursor.value);
                            cursor.continue();
                        } else {
                            resolve(anchors);
                        }
                    };
                });
            },

            async getEventProof(eventId) {
                const event = await dbOperation('events', 'readonly', store => store.get(eventId));
                if (!event || event.anchor_status !== 'ANCHORED') return null;
                const anchor = await dbOperation('anchors', 'readonly', store => store.get(event.anchor_reference));
                if (!anchor || !anchor.tree) return null;
                const auditPath = generateAuditPath(anchor.tree, event.merkle_index);
                return {
                    event_id: event.event_id,
                    event_hash: event.event_hash,
                    merkle_root: event.merkle_root,
                    merkle_index: event.merkle_index,
                    audit_path: auditPath,
                    anchor_id: event.anchor_reference
                };
            },

            async verifyCertificate(eventId) {
                const proof = await this.getEventProof(eventId);
                if (!proof) return { valid: false, reason: 'No proof available' };
                const event = await dbOperation('events', 'readonly', store => store.get(eventId));
                const isValid = await verifyMerkleProof(event.event_hash, proof.merkle_root, proof.audit_path);
                return {
                    valid: isValid,
                    certificate: {
                        certificate_id: generateUUIDv7(),
                        event_id: eventId,
                        event_hash: event.event_hash,
                        merkle_root: proof.merkle_root,
                        merkle_proof: proof.audit_path,
                        verified_at: new Date().toISOString(),
                        verification_method: 'RFC6962_MERKLE'
                    }
                };
            },

            async verifyWithCustomHash(customHash, merkleRoot, auditPath) {
                return await verifyMerkleProof(customHash, merkleRoot, auditPath);
            },

            async clearAll() {
                const db = await openDB();
                const tx = db.transaction(['events', 'anchors'], 'readwrite');
                tx.objectStore('events').clear();
                tx.objectStore('anchors').clear();
            },

            async getStats() {
                const events = await this.getEvents(1000);
                const anchors = await this.getAnchors();
                const pending = events.filter(e => e.anchor_status === 'PENDING').length;
                return { events_count: events.length, anchors_count: anchors.length, pending_count: pending };
            }
        };

        // =============================================================================
        // UI Components
        // =============================================================================

        const Badge = ({ color, children, className = '' }) => {
            const colors = {
                blue: 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200',
                green: 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200',
                yellow: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200',
                red: 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200',
                purple: 'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200',
                orange: 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200',
                gray: 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200'
            };
            return <span className={`px-2 py-1 rounded text-xs font-medium ${colors[color] || colors.gray} ${className}`}>{children}</span>;
        };

        const Card = ({ title, children, className = '' }) => (
            <div className={`bg-white dark:bg-gray-800 rounded-lg shadow p-4 ${className}`}>
                {title && <h3 className="font-semibold text-gray-700 dark:text-gray-200 mb-3">{title}</h3>}
                {children}
            </div>
        );

        const Modal = ({ isOpen, onClose, title, children }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-lg w-full max-h-[90vh] overflow-auto">
                        <div className="flex justify-between items-center p-4 border-b dark:border-gray-700">
                            <h3 className="font-semibold text-gray-700 dark:text-gray-200">{title}</h3>
                            <button onClick={onClose} className="text-gray-500 hover:text-gray-700 dark:hover:text-gray-300">âœ•</button>
                        </div>
                        <div className="p-4">{children}</div>
                    </div>
                </div>
            );
        };

        // =============================================================================
        // Merkle Tree Visualization Component
        // =============================================================================

        const MerkleTreeVisualization = ({ anchor, t, onSelectLeaf }) => {
            const [highlightedPath, setHighlightedPath] = useState([]);
            const [selectedLeaf, setSelectedLeaf] = useState(null);

            if (!anchor || !anchor.tree || anchor.tree.length === 0) {
                return <div className="text-gray-500 dark:text-gray-400 text-center py-8">No tree data available</div>;
            }

            const tree = anchor.tree;
            const maxWidth = tree[0].length;
            const height = tree.length;

            const handleLeafClick = (leafIndex) => {
                setSelectedLeaf(leafIndex);
                const path = generateAuditPath(tree, leafIndex);
                const highlighted = [{ level: 0, index: leafIndex }];
                let idx = leafIndex;
                for (let level = 0; level < tree.length - 1; level++) {
                    const parentIdx = Math.floor(idx / 2);
                    highlighted.push({ level: level + 1, index: parentIdx });
                    idx = parentIdx;
                }
                path.forEach(p => {
                    highlighted.push({ level: p.level, index: p.siblingIdx });
                });
                setHighlightedPath(highlighted);
                if (onSelectLeaf) onSelectLeaf(leafIndex, path);
            };

            const isHighlighted = (level, index) => {
                return highlightedPath.some(h => h.level === level && h.index === index);
            };

            const nodeWidth = 60;
            const nodeHeight = 30;
            const levelGap = 50;
            const svgWidth = Math.max(maxWidth * (nodeWidth + 20), 400);
            const svgHeight = height * levelGap + 60;

            return (
                <div className="overflow-auto">
                    <svg width={svgWidth} height={svgHeight} className="mx-auto">
                        {tree.map((level, levelIdx) => {
                            const y = svgHeight - (levelIdx + 1) * levelGap;
                            const levelWidth = level.length * (nodeWidth + 10);
                            const startX = (svgWidth - levelWidth) / 2;

                            return level.map((hash, nodeIdx) => {
                                const x = startX + nodeIdx * (nodeWidth + 10) + nodeWidth / 2;
                                const highlighted = isHighlighted(levelIdx, nodeIdx);

                                // Draw line to parent
                                let line = null;
                                if (levelIdx < tree.length - 1) {
                                    const parentIdx = Math.floor(nodeIdx / 2);
                                    const parentLevel = tree[levelIdx + 1];
                                    const parentLevelWidth = parentLevel.length * (nodeWidth + 10);
                                    const parentStartX = (svgWidth - parentLevelWidth) / 2;
                                    const parentX = parentStartX + parentIdx * (nodeWidth + 10) + nodeWidth / 2;
                                    const parentY = svgHeight - (levelIdx + 2) * levelGap + nodeHeight / 2;
                                    const lineHighlighted = highlighted && isHighlighted(levelIdx + 1, parentIdx);
                                    line = (
                                        <line
                                            key={`line-${levelIdx}-${nodeIdx}`}
                                            x1={x}
                                            y1={y}
                                            x2={parentX}
                                            y2={parentY}
                                            className={`tree-line ${lineHighlighted ? 'highlighted' : ''}`}
                                        />
                                    );
                                }

                                return (
                                    <g key={`node-${levelIdx}-${nodeIdx}`}>
                                        {line}
                                        <rect
                                            x={x - nodeWidth / 2}
                                            y={y}
                                            width={nodeWidth}
                                            height={nodeHeight}
                                            rx="4"
                                            className={`tree-node cursor-pointer ${highlighted ? 'fill-yellow-300 dark:fill-yellow-600' : 'fill-gray-200 dark:fill-gray-600'}`}
                                            onClick={() => levelIdx === 0 && handleLeafClick(nodeIdx)}
                                        />
                                        <text
                                            x={x}
                                            y={y + nodeHeight / 2 + 4}
                                            textAnchor="middle"
                                            className="text-xs fill-gray-700 dark:fill-gray-200 pointer-events-none"
                                        >
                                            {levelIdx === tree.length - 1 ? 'ROOT' : hash.slice(0, 6)}
                                        </text>
                                    </g>
                                );
                            });
                        })}
                    </svg>
                    <div className="text-center mt-2 text-sm text-gray-500 dark:text-gray-400">
                        {t('clickToHighlight')}
                    </div>
                </div>
            );
        };

        // =============================================================================
        // PDF Certificate Generator
        // =============================================================================

        const generateCertificatePDF = (certificate, event) => {
            const content = `
%PDF-1.4
1 0 obj << /Type /Catalog /Pages 2 0 R >> endobj
2 0 obj << /Type /Pages /Kids [3 0 R] /Count 1 >> endobj
3 0 obj << /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >> endobj
4 0 obj << /Length 1500 >> stream
BT
/F1 24 Tf
50 720 Td
(VCP VERIFICATION CERTIFICATE) Tj
/F1 12 Tf
0 -40 Td
(Certificate ID: ${certificate.certificate_id}) Tj
0 -20 Td
(Verified At: ${certificate.verified_at}) Tj
0 -20 Td
(Verification Method: ${certificate.verification_method}) Tj
0 -40 Td
(EVENT DETAILS) Tj
0 -20 Td
(Event ID: ${event.event_id}) Tj
0 -20 Td
(Event Type: ${event.event_type}) Tj
0 -20 Td
(Symbol: ${event.symbol}) Tj
0 -20 Td
(Timestamp: ${event.timestamp_iso}) Tj
0 -40 Td
(CRYPTOGRAPHIC PROOF) Tj
0 -20 Td
(Event Hash:) Tj
0 -15 Td
(${certificate.event_hash}) Tj
0 -25 Td
(Merkle Root:) Tj
0 -15 Td
(${certificate.merkle_root}) Tj
0 -25 Td
(Audit Path: ${certificate.merkle_proof.length} steps) Tj
0 -40 Td
(---) Tj
0 -20 Td
(This certificate was generated by VCC Demo) Tj
0 -15 Td
(VeritasChain Standards Organization - veritaschain.org) Tj
0 -15 Td
(Verify, Don't Trust) Tj
ET
endstream endobj
5 0 obj << /Type /Font /Subtype /Type1 /BaseFont /Helvetica >> endobj
xref
0 6
0000000000 65535 f
0000000009 00000 n
0000000058 00000 n
0000000115 00000 n
0000000266 00000 n
0000001820 00000 n
trailer << /Size 6 /Root 1 0 R >>
startxref
1897
%%EOF`;
            const blob = new Blob([content], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `VCP_Certificate_${certificate.certificate_id.slice(0, 8)}.pdf`;
            a.click();
            URL.revokeObjectURL(url);
        };

        // =============================================================================
        // Main App Component
        // =============================================================================

        const App = () => {
            const [events, setEvents] = useState([]);
            const [anchors, setAnchors] = useState([]);
            const [stats, setStats] = useState({ events_count: 0, anchors_count: 0, pending_count: 0 });
            const [activeTab, setActiveTab] = useState('dashboard');
            const [verifyResult, setVerifyResult] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [darkMode, setDarkMode] = useState(false);
            const [language, setLanguage] = useState('en');
            const [searchQuery, setSearchQuery] = useState('');
            const [filterType, setFilterType] = useState('');
            const [filterStatus, setFilterStatus] = useState('');

            // Form state
            const [formSymbol, setFormSymbol] = useState('XAUUSD');
            const [formAccount, setFormAccount] = useState('demo-trader-001');
            const [formEventType, setFormEventType] = useState('SIG');

            // Tamper demo state
            const [tamperEvent, setTamperEvent] = useState(null);
            const [tamperedData, setTamperedData] = useState(null);
            const [tamperResult, setTamperResult] = useState(null);

            // Tree visualization state
            const [selectedAnchor, setSelectedAnchor] = useState(null);
            const [selectedLeafPath, setSelectedLeafPath] = useState(null);

            // Simulator state
            const [simulatorRunning, setSimulatorRunning] = useState(false);
            const [simulatorCount, setSimulatorCount] = useState(0);
            const [autoAnchor, setAutoAnchor] = useState(true);
            const [prices, setPrices] = useState({
                XAUUSD: 2650.00,
                EURUSD: 1.0850,
                BTCUSD: 42500.00,
                USDJPY: 148.50
            });
            const simulatorRef = useRef(null);

            // QR Modal state
            const [qrModalOpen, setQrModalOpen] = useState(false);
            const [qrData, setQrData] = useState('');
            const qrCanvasRef = useRef(null);

            const t = useTranslation(language);

            const loadData = useCallback(async () => {
                const [evts, anchs, st] = await Promise.all([
                    VCCService.getEvents(),
                    VCCService.getAnchors(),
                    VCCService.getStats()
                ]);
                setEvents(evts);
                setAnchors(anchs);
                setStats(st);
            }, []);

            useEffect(() => { loadData(); }, [loadData]);

            useEffect(() => {
                if (darkMode) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            }, [darkMode]);

            // Generate QR code when modal opens
            useEffect(() => {
                if (qrModalOpen && qrData && qrCanvasRef.current) {
                    QRCode.toCanvas(qrCanvasRef.current, qrData, { width: 200 });
                }
            }, [qrModalOpen, qrData]);

            // Simulator logic
            useEffect(() => {
                if (simulatorRunning) {
                    simulatorRef.current = setInterval(async () => {
                        // Update prices
                        setPrices(prev => ({
                            XAUUSD: prev.XAUUSD + (Math.random() - 0.5) * 2,
                            EURUSD: prev.EURUSD + (Math.random() - 0.5) * 0.001,
                            BTCUSD: prev.BTCUSD + (Math.random() - 0.5) * 100,
                            USDJPY: prev.USDJPY + (Math.random() - 0.5) * 0.2
                        }));

                        // Generate random event
                        const symbols = ['XAUUSD', 'EURUSD', 'BTCUSD', 'USDJPY'];
                        const types = ['SIG', 'ORD', 'ACK', 'EXE'];
                        const symbol = symbols[Math.floor(Math.random() * symbols.length)];
                        const type = types[Math.floor(Math.random() * types.length)];
                        
                        await VCCService.createEvent(type, symbol, 'simulator-001', {
                            price: prices[symbol]?.toFixed(symbol === 'BTCUSD' ? 2 : symbol === 'EURUSD' ? 5 : 2),
                            quantity: (Math.random() * 0.5).toFixed(2)
                        });

                        setSimulatorCount(c => {
                            const newCount = c + 1;
                            if (autoAnchor && newCount % 10 === 0) {
                                VCCService.createAnchor().then(() => loadData());
                            }
                            return newCount;
                        });

                        await loadData();
                    }, 1000);
                } else {
                    if (simulatorRef.current) {
                        clearInterval(simulatorRef.current);
                    }
                }
                return () => {
                    if (simulatorRef.current) {
                        clearInterval(simulatorRef.current);
                    }
                };
            }, [simulatorRunning, autoAnchor, prices, loadData]);

            const handleCreateEvent = async () => {
                setIsLoading(true);
                await VCCService.createEvent(formEventType, formSymbol, formAccount, {
                    price: (2650 + Math.random() * 10).toFixed(2),
                    quantity: '0.1'
                });
                await loadData();
                setIsLoading(false);
            };

            const handleCreateTradeFlow = async () => {
                setIsLoading(true);
                const traceId = generateUUIDv7();
                for (const type of ['SIG', 'ORD', 'ACK', 'EXE', 'CLS']) {
                    await VCCService.createEvent(type, formSymbol, formAccount, {
                        trace_id: traceId,
                        price: (2650 + Math.random() * 10).toFixed(2),
                        quantity: '0.1'
                    });
                    await new Promise(r => setTimeout(r, 100));
                }
                await loadData();
                setIsLoading(false);
            };

            const handleCreateAnchor = async () => {
                setIsLoading(true);
                await VCCService.createAnchor();
                await loadData();
                setIsLoading(false);
            };

            const handleVerify = async (eventId) => {
                const result = await VCCService.verifyCertificate(eventId);
                setVerifyResult(result);
            };

            const handleClearAll = async () => {
                if (confirm('Clear all data? This cannot be undone.')) {
                    await VCCService.clearAll();
                    await loadData();
                    setVerifyResult(null);
                    setTamperEvent(null);
                    setTamperedData(null);
                    setTamperResult(null);
                }
            };

            const handleExportJson = (data, filename) => {
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            };

            const handleShowQR = (data) => {
                setQrData(JSON.stringify(data));
                setQrModalOpen(true);
            };

            // Tamper demo handlers
            const handleSelectTamperEvent = async (eventId) => {
                const event = events.find(e => e.event_id === eventId);
                if (event) {
                    setTamperEvent(event);
                    setTamperedData(null);
                    setTamperResult(null);
                }
            };

            const handleSimulateTamper = () => {
                if (!tamperEvent) return;
                const tampered = { ...tamperEvent };
                tampered.payload = { ...tampered.payload, price: '9999.99', tampered: true };
                setTamperedData(tampered);
                setTamperResult(null);
            };

            const handleVerifyTampered = async () => {
                if (!tamperedData || !tamperEvent) return;
                const tamperedHashInput = {
                    event_id: tamperedData.event_id,
                    trace_id: tamperedData.trace_id,
                    timestamp_int: tamperedData.timestamp_int,
                    event_type: tamperedData.event_type,
                    symbol: tamperedData.symbol,
                    venue_id: tamperedData.venue_id,
                    account_id: tamperedData.account_id,
                    payload: tamperedData.payload
                };
                const tamperedHash = await sha256(tamperedHashInput);
                
                const proof = await VCCService.getEventProof(tamperEvent.event_id);
                if (!proof) {
                    setTamperResult({ valid: false, reason: 'No proof available' });
                    return;
                }

                const isValid = await VCCService.verifyWithCustomHash(tamperedHash, proof.merkle_root, proof.audit_path);
                setTamperResult({
                    valid: isValid,
                    originalHash: tamperEvent.event_hash,
                    tamperedHash: tamperedHash,
                    merkleRoot: proof.merkle_root
                });
            };

            // Filtered events
            const filteredEvents = useMemo(() => {
                return events.filter(e => {
                    if (searchQuery) {
                        const q = searchQuery.toLowerCase();
                        if (!e.trace_id.toLowerCase().includes(q) && 
                            !e.symbol.toLowerCase().includes(q) &&
                            !e.event_id.toLowerCase().includes(q)) {
                            return false;
                        }
                    }
                    if (filterType && e.event_type !== filterType) return false;
                    if (filterStatus && e.anchor_status !== filterStatus) return false;
                    return true;
                });
            }, [events, searchQuery, filterType, filterStatus]);

            const tabs = [
                { id: 'dashboard', label: t('dashboard') },
                { id: 'events', label: t('events') },
                { id: 'anchors', label: t('anchors') },
                { id: 'verify', label: t('verify') },
                { id: 'tamper', label: t('tamper') },
                { id: 'tree', label: t('tree') },
                { id: 'simulator', label: t('simulator') }
            ];

            return (
                <div className="min-h-screen bg-gray-50 dark:bg-gray-900 transition-colors">
                    {/* Header */}
                    <header className="bg-gradient-to-r from-vcc-700 to-vcc-800 text-white shadow-lg">
                        <div className="max-w-7xl mx-auto px-4 py-4">
                            <div className="flex items-center justify-between flex-wrap gap-4">
                                <div>
                                    <h1 className="text-2xl font-bold">{t('title')}</h1>
                                    <p className="text-vcc-100 text-sm">{t('subtitle')}</p>
                                </div>
                                <div className="flex items-center gap-4">
                                    <select
                                        value={language}
                                        onChange={e => setLanguage(e.target.value)}
                                        className="bg-vcc-600 text-white rounded px-2 py-1 text-sm"
                                    >
                                        <option value="en">English</option>
                                        <option value="ja">æ—¥æœ¬èªž</option>
                                        <option value="zh">ä¸­æ–‡</option>
                                        <option value="es">EspaÃ±ol</option>
                                    </select>
                                    <button
                                        onClick={() => setDarkMode(!darkMode)}
                                        className="bg-vcc-600 hover:bg-vcc-500 px-3 py-1 rounded text-sm"
                                    >
                                        {darkMode ? 'â˜€ï¸' : 'ðŸŒ™'} {darkMode ? t('lightMode') : t('darkMode')}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </header>

                    {/* Nav */}
                    <nav className="bg-white dark:bg-gray-800 border-b dark:border-gray-700 overflow-x-auto">
                        <div className="max-w-7xl mx-auto px-4">
                            <div className="flex space-x-2">
                                {tabs.map(tab => (
                                    <button
                                        key={tab.id}
                                        onClick={() => setActiveTab(tab.id)}
                                        className={`py-3 px-4 text-sm font-medium border-b-2 whitespace-nowrap ${
                                            activeTab === tab.id
                                                ? 'border-vcc-500 text-vcc-600 dark:text-vcc-400'
                                                : 'border-transparent text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300'
                                        }`}
                                    >
                                        {tab.label}
                                    </button>
                                ))}
                            </div>
                        </div>
                    </nav>

                    {/* Main Content */}
                    <main className="max-w-7xl mx-auto px-4 py-6">
                        {/* Dashboard Tab */}
                        {activeTab === 'dashboard' && (
                            <div className="space-y-6">
                                {/* Stats */}
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    <Card>
                                        <div className="text-3xl font-bold text-vcc-600 dark:text-vcc-400">{stats.events_count}</div>
                                        <div className="text-sm text-gray-500 dark:text-gray-400">{t('totalEvents')}</div>
                                    </Card>
                                    <Card>
                                        <div className="text-3xl font-bold text-blue-600 dark:text-blue-400">{stats.anchors_count}</div>
                                        <div className="text-sm text-gray-500 dark:text-gray-400">{t('anchorsCreated')}</div>
                                    </Card>
                                    <Card>
                                        <div className="text-3xl font-bold text-yellow-600 dark:text-yellow-400">{stats.pending_count}</div>
                                        <div className="text-sm text-gray-500 dark:text-gray-400">{t('pendingEvents')}</div>
                                    </Card>
                                </div>

                                {/* Quick Actions */}
                                <Card title={t('quickActions')}>
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <div className="space-y-3">
                                            <div className="flex gap-2 flex-wrap">
                                                <select value={formSymbol} onChange={e => setFormSymbol(e.target.value)} className="border dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded px-3 py-2 text-sm">
                                                    <option>XAUUSD</option>
                                                    <option>EURUSD</option>
                                                    <option>BTCUSD</option>
                                                    <option>USDJPY</option>
                                                </select>
                                                <select value={formEventType} onChange={e => setFormEventType(e.target.value)} className="border dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded px-3 py-2 text-sm">
                                                    {Object.keys(EVENT_TYPES).map(t => (<option key={t} value={t}>{t}</option>))}
                                                </select>
                                            </div>
                                            <input value={formAccount} onChange={e => setFormAccount(e.target.value)} placeholder="Account ID" className="border dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded px-3 py-2 text-sm w-full" />
                                        </div>
                                        <div className="space-y-2">
                                            <button onClick={handleCreateEvent} disabled={isLoading} className="w-full bg-vcc-600 text-white py-2 rounded hover:bg-vcc-700 disabled:opacity-50 text-sm">{t('createSingleEvent')}</button>
                                            <button onClick={handleCreateTradeFlow} disabled={isLoading} className="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 disabled:opacity-50 text-sm">{t('createTradeFlow')}</button>
                                            <button onClick={handleCreateAnchor} disabled={isLoading || stats.pending_count === 0} className="w-full bg-purple-600 text-white py-2 rounded hover:bg-purple-700 disabled:opacity-50 text-sm">{t('createMerkleAnchor')} ({stats.pending_count} {t('pending')})</button>
                                        </div>
                                    </div>
                                </Card>

                                {/* Recent Events */}
                                <Card title={t('recentEvents')}>
                                    {events.length === 0 ? (
                                        <p className="text-gray-500 dark:text-gray-400 text-sm">{t('noEventsYet')}</p>
                                    ) : (
                                        <div className="overflow-x-auto">
                                            <table className="w-full text-sm">
                                                <thead className="bg-gray-50 dark:bg-gray-700">
                                                    <tr>
                                                        <th className="text-left py-2 px-3 text-gray-600 dark:text-gray-300">{t('type')}</th>
                                                        <th className="text-left py-2 px-3 text-gray-600 dark:text-gray-300">{t('symbol')}</th>
                                                        <th className="text-left py-2 px-3 text-gray-600 dark:text-gray-300">{t('hash')}</th>
                                                        <th className="text-left py-2 px-3 text-gray-600 dark:text-gray-300">{t('status')}</th>
                                                        <th className="text-left py-2 px-3 text-gray-600 dark:text-gray-300">{t('time')}</th>
                                                        <th className="text-left py-2 px-3 text-gray-600 dark:text-gray-300">{t('action')}</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    {events.slice(0, 10).map(e => (
                                                        <tr key={e.event_id} className="border-b dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700">
                                                            <td className="py-2 px-3"><Badge color={EVENT_TYPES[e.event_type]?.color}>{e.event_type}</Badge></td>
                                                            <td className="py-2 px-3 mono text-xs dark:text-gray-300">{e.symbol}</td>
                                                            <td className="py-2 px-3 mono hash-text text-gray-500 dark:text-gray-400">{e.event_hash?.slice(0, 16)}...</td>
                                                            <td className="py-2 px-3"><Badge color={e.anchor_status === 'ANCHORED' ? 'green' : 'yellow'}>{e.anchor_status}</Badge></td>
                                                            <td className="py-2 px-3 text-xs text-gray-500 dark:text-gray-400">{new Date(e.timestamp_iso).toLocaleTimeString()}</td>
                                                            <td className="py-2 px-3">
                                                                {e.anchor_status === 'ANCHORED' && (
                                                                    <button onClick={() => { setActiveTab('verify'); handleVerify(e.event_id); }} className="text-xs text-vcc-600 hover:text-vcc-800 dark:text-vcc-400 font-medium">{t('verifyBtn')}</button>
                                                                )}
                                                            </td>
                                                        </tr>
                                                    ))}
                                                </tbody>
                                            </table>
                                        </div>
                                    )}
                                </Card>
                            </div>
                        )}

                        {/* Events Tab */}
                        {activeTab === 'events' && (
                            <div className="space-y-4">
                                {/* Search & Filter */}
                                <Card title={t('searchFilter')}>
                                    <div className="flex flex-wrap gap-4">
                                        <input
                                            type="text"
                                            value={searchQuery}
                                            onChange={e => setSearchQuery(e.target.value)}
                                            placeholder={t('searchPlaceholder')}
                                            className="border dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded px-3 py-2 text-sm flex-1 min-w-[200px]"
                                        />
                                        <select value={filterType} onChange={e => setFilterType(e.target.value)} className="border dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded px-3 py-2 text-sm">
                                            <option value="">{t('allTypes')}</option>
                                            {Object.keys(EVENT_TYPES).map(t => (<option key={t} value={t}>{t}</option>))}
                                        </select>
                                        <select value={filterStatus} onChange={e => setFilterStatus(e.target.value)} className="border dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded px-3 py-2 text-sm">
                                            <option value="">{t('allStatuses')}</option>
                                            <option value="PENDING">PENDING</option>
                                            <option value="ANCHORED">ANCHORED</option>
                                        </select>
                                        <button onClick={() => handleExportJson(filteredEvents, 'vcc-events.json')} className="bg-gray-600 text-white px-4 py-2 rounded text-sm hover:bg-gray-700">{t('exportJson')}</button>
                                    </div>
                                </Card>

                                <Card title={`${t('allEvents')} (${filteredEvents.length})`}>
                                    <div className="overflow-x-auto max-h-96 overflow-y-auto">
                                        <table className="w-full text-sm">
                                            <thead className="bg-gray-50 dark:bg-gray-700 sticky top-0">
                                                <tr>
                                                    <th className="text-left py-2 px-3 text-gray-600 dark:text-gray-300">{t('type')}</th>
                                                    <th className="text-left py-2 px-3 text-gray-600 dark:text-gray-300">{t('symbol')}</th>
                                                    <th className="text-left py-2 px-3 text-gray-600 dark:text-gray-300">{t('eventHash')}</th>
                                                    <th className="text-left py-2 px-3 text-gray-600 dark:text-gray-300">{t('merkleRoot')}</th>
                                                    <th className="text-left py-2 px-3 text-gray-600 dark:text-gray-300">{t('status')}</th>
                                                    <th className="text-left py-2 px-3 text-gray-600 dark:text-gray-300">{t('time')}</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {filteredEvents.map(e => (
                                                    <tr key={e.event_id} className="border-b dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700">
                                                        <td className="py-2 px-3"><Badge color={EVENT_TYPES[e.event_type]?.color}>{e.event_type}</Badge></td>
                                                        <td className="py-2 px-3 mono text-xs dark:text-gray-300">{e.symbol}</td>
                                                        <td className="py-2 px-3 mono hash-text text-gray-500 dark:text-gray-400">{e.event_hash?.slice(0, 20)}...</td>
                                                        <td className="py-2 px-3 mono hash-text text-gray-500 dark:text-gray-400">{e.merkle_root?.slice(0, 20) || '-'}...</td>
                                                        <td className="py-2 px-3"><Badge color={e.anchor_status === 'ANCHORED' ? 'green' : 'yellow'}>{e.anchor_status}</Badge></td>
                                                        <td className="py-2 px-3 text-xs text-gray-500 dark:text-gray-400">{new Date(e.timestamp_iso).toLocaleString()}</td>
                                                    </tr>
                                                ))}
                                            </tbody>
                                        </table>
                                    </div>
                                </Card>
                            </div>
                        )}

                        {/* Anchors Tab */}
                        {activeTab === 'anchors' && (
                            <Card title={`${t('anchorRecords')} (${anchors.length})`}>
                                {anchors.length === 0 ? (
                                    <p className="text-gray-500 dark:text-gray-400 text-sm">{t('noAnchorsYet')}</p>
                                ) : (
                                    <div className="space-y-4">
                                        {anchors.map(a => (
                                            <div key={a.anchor_id} className="border dark:border-gray-700 rounded-lg p-4 bg-gray-50 dark:bg-gray-700">
                                                <div className="flex justify-between items-start flex-wrap gap-2">
                                                    <div>
                                                        <div className="font-medium dark:text-white">Anchor #{a.anchor_id.slice(0, 8)}...</div>
                                                        <div className="text-sm text-gray-500 dark:text-gray-400">{a.event_count} events</div>
                                                    </div>
                                                    <div className="flex items-center gap-2">
                                                        <Badge color="green">{a.status}</Badge>
                                                        <button onClick={() => handleExportJson(a, `anchor-${a.anchor_id.slice(0,8)}.json`)} className="text-xs text-gray-600 dark:text-gray-400 hover:text-gray-800">{t('exportJson')}</button>
                                                    </div>
                                                </div>
                                                <div className="mt-3 space-y-1">
                                                    <div className="text-xs">
                                                        <span className="text-gray-500 dark:text-gray-400">{t('merkleRoot')}: </span>
                                                        <span className="mono text-gray-700 dark:text-gray-300">{a.merkle_root}</span>
                                                    </div>
                                                    <div className="text-xs text-gray-500 dark:text-gray-400">
                                                        Created: {new Date(a.timestamp_iso).toLocaleString()}
                                                    </div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </Card>
                        )}

                        {/* Verify Tab */}
                        {activeTab === 'verify' && (
                            <div className="space-y-6">
                                <Card title={`${t('verifyEvent')} - ${t('verifyDontTrust')}`}>
                                    <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">{t('verifySubtitle')}</p>
                                    <select className="w-full border dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded px-3 py-2 text-sm" onChange={e => e.target.value && handleVerify(e.target.value)}>
                                        <option value="">{t('selectAnchored')}</option>
                                        {events.filter(e => e.anchor_status === 'ANCHORED').map(e => (
                                            <option key={e.event_id} value={e.event_id}>{e.event_type} - {e.symbol} - {e.event_hash?.slice(0, 12)}...</option>
                                        ))}
                                    </select>
                                </Card>

                                {verifyResult && (
                                    <Card title={t('verificationResult')}>
                                        <div className={`p-4 rounded-lg ${verifyResult.valid ? 'bg-green-50 dark:bg-green-900/30 border border-green-200 dark:border-green-800' : 'bg-red-50 dark:bg-red-900/30 border border-red-200 dark:border-red-800'}`}>
                                            <div className="flex items-center gap-2 mb-3">
                                                <span className="text-2xl">{verifyResult.valid ? 'âœ…' : 'âŒ'}</span>
                                                <span className={`font-bold ${verifyResult.valid ? 'text-green-700 dark:text-green-400' : 'text-red-700 dark:text-red-400'}`}>
                                                    {verifyResult.valid ? t('verificationPassed') : t('verificationFailed')}
                                                </span>
                                            </div>
                                            {verifyResult.valid && verifyResult.certificate && (
                                                <div className="space-y-2 text-sm">
                                                    <div className="dark:text-gray-300"><strong>{t('certificateId')}:</strong> <span className="mono">{verifyResult.certificate.certificate_id}</span></div>
                                                    <div className="dark:text-gray-300"><strong>{t('eventHash')}:</strong> <span className="mono text-xs">{verifyResult.certificate.event_hash}</span></div>
                                                    <div className="dark:text-gray-300"><strong>{t('merkleRoot')}:</strong> <span className="mono text-xs">{verifyResult.certificate.merkle_root}</span></div>
                                                    <div className="dark:text-gray-300"><strong>{t('verificationMethod')}:</strong> {verifyResult.certificate.verification_method}</div>
                                                    <div className="dark:text-gray-300"><strong>{t('verifiedAt')}:</strong> {verifyResult.certificate.verified_at}</div>
                                                    <div className="mt-3">
                                                        <strong className="dark:text-gray-300">{t('merkleProof')} ({verifyResult.certificate.merkle_proof?.length} {t('steps')}):</strong>
                                                        <pre className="mt-1 p-2 bg-white dark:bg-gray-800 rounded text-xs overflow-x-auto dark:text-gray-300">
                                                            {JSON.stringify(verifyResult.certificate.merkle_proof.map(p => ({ hash: p.hash.slice(0, 16) + '...', position: p.position })), null, 2)}
                                                        </pre>
                                                    </div>
                                                    <div className="flex gap-2 mt-4 flex-wrap">
                                                        <button onClick={() => handleExportJson(verifyResult.certificate, `certificate-${verifyResult.certificate.certificate_id.slice(0,8)}.json`)} className="bg-gray-600 text-white px-3 py-1 rounded text-sm hover:bg-gray-700">{t('exportCert')}</button>
                                                        <button onClick={() => handleShowQR(verifyResult.certificate)} className="bg-blue-600 text-white px-3 py-1 rounded text-sm hover:bg-blue-700">{t('showQr')}</button>
                                                        <button onClick={() => generateCertificatePDF(verifyResult.certificate, events.find(e => e.event_id === verifyResult.certificate.event_id))} className="bg-purple-600 text-white px-3 py-1 rounded text-sm hover:bg-purple-700">{t('downloadPdf')}</button>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    </Card>
                                )}
                            </div>
                        )}

                        {/* Tamper Demo Tab */}
                        {activeTab === 'tamper' && (
                            <div className="space-y-6">
                                <Card title={t('tamperDemo')}>
                                    <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">{t('tamperSubtitle')}</p>
                                    
                                    <div className="mb-4">
                                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">{t('selectEventToTamper')}</label>
                                        <select className="w-full border dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded px-3 py-2 text-sm" onChange={e => handleSelectTamperEvent(e.target.value)}>
                                            <option value="">{t('selectAnchored')}</option>
                                            {events.filter(e => e.anchor_status === 'ANCHORED').map(e => (
                                                <option key={e.event_id} value={e.event_id}>{e.event_type} - {e.symbol} - {e.event_hash?.slice(0, 12)}...</option>
                                            ))}
                                        </select>
                                    </div>

                                    {tamperEvent && (
                                        <div className="space-y-4">
                                            <div className="p-4 bg-green-50 dark:bg-green-900/30 rounded-lg border border-green-200 dark:border-green-800">
                                                <h4 className="font-medium text-green-800 dark:text-green-400 mb-2">{t('originalData')}</h4>
                                                <pre className="text-xs overflow-x-auto dark:text-gray-300">{JSON.stringify({ event_type: tamperEvent.event_type, symbol: tamperEvent.symbol, payload: tamperEvent.payload }, null, 2)}</pre>
                                                <div className="mt-2 text-xs text-green-600 dark:text-green-400 mono">Hash: {tamperEvent.event_hash}</div>
                                            </div>

                                            <button onClick={handleSimulateTamper} className="w-full bg-red-600 text-white py-2 rounded hover:bg-red-700 tamper-pulse">{t('simulateTamper')}</button>

                                            {tamperedData && (
                                                <>
                                                    <div className="p-4 bg-red-50 dark:bg-red-900/30 rounded-lg border border-red-200 dark:border-red-800">
                                                        <h4 className="font-medium text-red-800 dark:text-red-400 mb-2">{t('tamperedData')}</h4>
                                                        <pre className="text-xs overflow-x-auto dark:text-gray-300">{JSON.stringify({ event_type: tamperedData.event_type, symbol: tamperedData.symbol, payload: tamperedData.payload }, null, 2)}</pre>
                                                    </div>

                                                    <button onClick={handleVerifyTampered} className="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700">{t('verifyTampered')}</button>
                                                </>
                                            )}

                                            {tamperResult && (
                                                <div className={`p-4 rounded-lg ${tamperResult.valid ? 'bg-green-50 dark:bg-green-900/30' : 'bg-red-50 dark:bg-red-900/30'}`}>
                                                    <div className="flex items-center gap-2 mb-3">
                                                        <span className="text-2xl">{tamperResult.valid ? 'âœ…' : 'âŒ'}</span>
                                                        <span className={`font-bold ${tamperResult.valid ? 'text-green-700 dark:text-green-400' : 'text-red-700 dark:text-red-400'}`}>
                                                            {tamperResult.valid ? t('verificationPassed') : t('verificationFailed')}
                                                        </span>
                                                    </div>

                                                    {!tamperResult.valid && (
                                                        <div className="space-y-3 text-sm">
                                                            <div className="p-3 bg-white dark:bg-gray-800 rounded">
                                                                <div className="text-xs text-gray-500 dark:text-gray-400">Original Hash:</div>
                                                                <div className="mono text-xs text-green-600 dark:text-green-400">{tamperResult.originalHash}</div>
                                                            </div>
                                                            <div className="p-3 bg-white dark:bg-gray-800 rounded">
                                                                <div className="text-xs text-gray-500 dark:text-gray-400">Tampered Hash:</div>
                                                                <div className="mono text-xs text-red-600 dark:text-red-400">{tamperResult.tamperedHash}</div>
                                                            </div>
                                                            <div className="p-3 bg-white dark:bg-gray-800 rounded">
                                                                <div className="text-xs text-gray-500 dark:text-gray-400">Merkle Root:</div>
                                                                <div className="mono text-xs dark:text-gray-300">{tamperResult.merkleRoot}</div>
                                                            </div>

                                                            <div className="mt-4 p-4 bg-yellow-50 dark:bg-yellow-900/30 rounded-lg border border-yellow-200 dark:border-yellow-800">
                                                                <h4 className="font-medium text-yellow-800 dark:text-yellow-400 mb-2">{t('tamperExplanation')}</h4>
                                                                <ul className="text-sm text-yellow-700 dark:text-yellow-300 space-y-1">
                                                                    <li>{t('tamperReason1')}</li>
                                                                    <li>{t('tamperReason2')}</li>
                                                                    <li>{t('tamperReason3')}</li>
                                                                    <li>{t('tamperReason4')}</li>
                                                                </ul>
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            )}

                                            <button onClick={() => { setTamperEvent(null); setTamperedData(null); setTamperResult(null); }} className="text-sm text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300">{t('resetTamper')}</button>
                                        </div>
                                    )}
                                </Card>
                            </div>
                        )}

                        {/* Tree Visualization Tab */}
                        {activeTab === 'tree' && (
                            <div className="space-y-6">
                                <Card title={t('treeVisualization')}>
                                    <div className="mb-4">
                                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">{t('selectAnchorToVisualize')}</label>
                                        <select className="w-full border dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded px-3 py-2 text-sm" onChange={e => setSelectedAnchor(anchors.find(a => a.anchor_id === e.target.value))}>
                                            <option value="">{t('selectAnchor')}</option>
                                            {anchors.map(a => (
                                                <option key={a.anchor_id} value={a.anchor_id}>Anchor #{a.anchor_id.slice(0, 8)}... ({a.event_count} events)</option>
                                            ))}
                                        </select>
                                    </div>

                                    {selectedAnchor && (
                                        <div className="space-y-4">
                                            <div className="grid grid-cols-2 gap-4">
                                                <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded">
                                                    <div className="text-xs text-gray-500 dark:text-gray-400">{t('treeDepth')}</div>
                                                    <div className="text-lg font-bold dark:text-white">{selectedAnchor.tree?.length || 0}</div>
                                                </div>
                                                <div className="p-3 bg-gray-50 dark:bg-gray-700 rounded">
                                                    <div className="text-xs text-gray-500 dark:text-gray-400">{t('leafCount')}</div>
                                                    <div className="text-lg font-bold dark:text-white">{selectedAnchor.tree?.[0]?.length || 0}</div>
                                                </div>
                                            </div>

                                            <div className="bg-gray-50 dark:bg-gray-700 rounded-lg p-4 overflow-x-auto">
                                                <MerkleTreeVisualization 
                                                    anchor={selectedAnchor} 
                                                    t={t}
                                                    onSelectLeaf={(idx, path) => setSelectedLeafPath({ index: idx, path })}
                                                />
                                            </div>

                                            {selectedLeafPath && (
                                                <div className="p-4 bg-blue-50 dark:bg-blue-900/30 rounded-lg">
                                                    <h4 className="font-medium text-blue-800 dark:text-blue-400 mb-2">{t('auditPath')} for Leaf #{selectedLeafPath.index}</h4>
                                                    <div className="space-y-2">
                                                        {selectedLeafPath.path.map((step, i) => (
                                                            <div key={i} className="text-xs mono dark:text-gray-300">
                                                                Step {i + 1}: {step.hash.slice(0, 24)}... ({step.position})
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </Card>
                            </div>
                        )}

                        {/* Simulator Tab */}
                        {activeTab === 'simulator' && (
                            <div className="space-y-6">
                                <Card title={t('liveSimulator')}>
                                    <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">{t('simulatorSubtitle')}</p>

                                    <div className="flex items-center gap-4 mb-4 flex-wrap">
                                        <button
                                            onClick={() => setSimulatorRunning(!simulatorRunning)}
                                            className={`px-4 py-2 rounded text-white ${simulatorRunning ? 'bg-red-600 hover:bg-red-700' : 'bg-green-600 hover:bg-green-700'}`}
                                        >
                                            {simulatorRunning ? t('stopSimulator') : t('startSimulator')}
                                        </button>
                                        <Badge color={simulatorRunning ? 'green' : 'gray'}>
                                            {simulatorRunning ? t('simulatorRunning') : t('simulatorStopped')}
                                        </Badge>
                                        <label className="flex items-center gap-2 text-sm dark:text-gray-300">
                                            <input type="checkbox" checked={autoAnchor} onChange={e => setAutoAnchor(e.target.checked)} className="rounded" />
                                            {t('autoAnchor')}
                                        </label>
                                    </div>

                                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                                        {Object.entries(prices).map(([symbol, price]) => (
                                            <div key={symbol} className="p-3 bg-gray-50 dark:bg-gray-700 rounded">
                                                <div className="text-xs text-gray-500 dark:text-gray-400">{symbol}</div>
                                                <div className="text-lg font-bold mono dark:text-white">
                                                    {symbol === 'EURUSD' ? price.toFixed(5) : symbol === 'BTCUSD' ? price.toFixed(2) : price.toFixed(2)}
                                                </div>
                                            </div>
                                        ))}
                                    </div>

                                    <div className="p-4 bg-blue-50 dark:bg-blue-900/30 rounded">
                                        <div className="text-sm text-blue-800 dark:text-blue-400">{t('eventsGenerated')}: <strong>{simulatorCount}</strong></div>
                                    </div>
                                </Card>
                            </div>
                        )}
                    </main>

                    {/* Footer */}
                    <footer className="bg-gray-800 dark:bg-gray-950 text-gray-400 py-6 mt-8">
                        <div className="max-w-7xl mx-auto px-4 text-center text-sm">
                            <p className="mb-2"><strong className="text-white">{t('title')}</strong> - {t('footer1')}</p>
                            <p className="text-xs mb-2">{t('footer2')}</p>
                            <p className="text-xs text-gray-500">{t('footer3')}</p>
                            <div className="mt-4 flex justify-center gap-4 flex-wrap">
                                <a href="https://veritaschain.org" className="text-vcc-400 hover:text-vcc-300">veritaschain.org</a>
                                <a href="https://github.com/veritaschain" className="text-vcc-400 hover:text-vcc-300">GitHub</a>
                                <button onClick={handleClearAll} className="text-red-400 hover:text-red-300">{t('clearAllData')}</button>
                            </div>
                            <p className="mt-4 text-xs text-gray-600">VeritasChain Standards Organization (VSO) â€¢ {t('verifyDontTrust')} â€¢ VCP v1.1</p>
                        </div>
                    </footer>

                    {/* QR Modal */}
                    <Modal isOpen={qrModalOpen} onClose={() => setQrModalOpen(false)} title={t('qrTitle')}>
                        <div className="text-center">
                            <canvas ref={qrCanvasRef} className="mx-auto mb-4"></canvas>
                            <p className="text-sm text-gray-500 dark:text-gray-400">{t('qrSubtitle')}</p>
                            <button onClick={() => setQrModalOpen(false)} className="mt-4 bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700">{t('close')}</button>
                        </div>
                    </Modal>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
