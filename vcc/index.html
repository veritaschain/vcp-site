<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VCC Demo - VeritasChain Cloud</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        vcc: { 50: '#f0fdf4', 100: '#dcfce7', 500: '#22c55e', 600: '#16a34a', 700: '#15803d', 800: '#166534', 900: '#14532d' }
                    }
                }
            }
        }
    </script>
    <style>
        .mono { font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace; }
        .hash-text { font-size: 0.7rem; word-break: break-all; }
    </style>
</head>
<body class="bg-gray-50">
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        // =============================================================================
        // VCP v1.1 Core Implementation (Client-Side)
        // =============================================================================

        // UUID v7 Generator
        const generateUUIDv7 = () => {
            const now = BigInt(Date.now());
            const timeHex = now.toString(16).padStart(12, '0');
            const randomBytes = new Uint8Array(10);
            crypto.getRandomValues(randomBytes);
            const randomHex = Array.from(randomBytes).map(b => b.toString(16).padStart(2, '0')).join('');
            const uuid = `${timeHex.slice(0,8)}-${timeHex.slice(8,12)}-7${randomHex.slice(0,3)}-${(0x80 | (parseInt(randomHex.slice(3,5), 16) & 0x3f)).toString(16)}${randomHex.slice(5,7)}-${randomHex.slice(7,19)}`;
            return uuid;
        };

        // SHA-256 Hash
        const sha256 = async (data) => {
            const encoder = new TextEncoder();
            const dataBuffer = encoder.encode(typeof data === 'string' ? data : JSON.stringify(data));
            const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
            return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
        };

        // RFC 6962 Merkle Tree
        const merkleHashLeaf = async (data) => {
            const prefix = new Uint8Array([0x00]);
            const dataBytes = new TextEncoder().encode(data);
            const combined = new Uint8Array(prefix.length + dataBytes.length);
            combined.set(prefix);
            combined.set(dataBytes, prefix.length);
            const hash = await crypto.subtle.digest('SHA-256', combined);
            return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
        };

        const merkleHashNode = async (left, right) => {
            const prefix = new Uint8Array([0x01]);
            const leftBytes = new Uint8Array(left.match(/.{2}/g).map(h => parseInt(h, 16)));
            const rightBytes = new Uint8Array(right.match(/.{2}/g).map(h => parseInt(h, 16)));
            const combined = new Uint8Array(prefix.length + leftBytes.length + rightBytes.length);
            combined.set(prefix);
            combined.set(leftBytes, prefix.length);
            combined.set(rightBytes, prefix.length + leftBytes.length);
            const hash = await crypto.subtle.digest('SHA-256', combined);
            return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
        };

        const buildMerkleTree = async (hashes) => {
            if (hashes.length === 0) return [];
            let leaves = await Promise.all(hashes.map(h => merkleHashLeaf(h)));
            const tree = [leaves];
            while (leaves.length > 1) {
                const nextLevel = [];
                for (let i = 0; i < leaves.length; i += 2) {
                    if (i + 1 < leaves.length) {
                        nextLevel.push(await merkleHashNode(leaves[i], leaves[i + 1]));
                    } else {
                        nextLevel.push(leaves[i]);
                    }
                }
                tree.push(nextLevel);
                leaves = nextLevel;
            }
            return tree;
        };

        const getMerkleRoot = (tree) => tree.length > 0 ? tree[tree.length - 1][0] : null;

        const generateAuditPath = (tree, leafIndex) => {
            const path = [];
            let idx = leafIndex;
            for (let level = 0; level < tree.length - 1; level++) {
                const isRight = idx % 2 === 1;
                const siblingIdx = isRight ? idx - 1 : idx + 1;
                if (siblingIdx < tree[level].length) {
                    path.push({ hash: tree[level][siblingIdx], position: isRight ? 'left' : 'right' });
                }
                idx = Math.floor(idx / 2);
            }
            return path;
        };

        const verifyMerkleProof = async (eventHash, merkleRoot, auditPath, leafIndex) => {
            let currentHash = await merkleHashLeaf(eventHash);
            for (const step of auditPath) {
                if (step.position === 'left') {
                    currentHash = await merkleHashNode(step.hash, currentHash);
                } else {
                    currentHash = await merkleHashNode(currentHash, step.hash);
                }
            }
            return currentHash === merkleRoot;
        };

        // Event Type Codes
        const EVENT_TYPES = {
            SIG: { code: 1, name: 'Signal Generated', color: 'blue' },
            ORD: { code: 2, name: 'Order Submitted', color: 'yellow' },
            ACK: { code: 3, name: 'Order Acknowledged', color: 'green' },
            REJ: { code: 4, name: 'Order Rejected', color: 'red' },
            EXE: { code: 5, name: 'Execution', color: 'purple' },
            CXL: { code: 6, name: 'Cancellation', color: 'orange' },
            CLS: { code: 10, name: 'Position Closed', color: 'gray' }
        };

        // =============================================================================
        // IndexedDB Storage
        // =============================================================================

        const DB_NAME = 'VCCDemo';
        const DB_VERSION = 1;

        const openDB = () => new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve(request.result);
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('events')) {
                    const eventStore = db.createObjectStore('events', { keyPath: 'event_id' });
                    eventStore.createIndex('trace_id', 'trace_id', { unique: false });
                    eventStore.createIndex('account_id', 'account_id', { unique: false });
                    eventStore.createIndex('timestamp', 'timestamp_int', { unique: false });
                }
                if (!db.objectStoreNames.contains('anchors')) {
                    db.createObjectStore('anchors', { keyPath: 'anchor_id' });
                }
            };
        });

        const dbOperation = async (storeName, mode, operation) => {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(storeName, mode);
                const store = tx.objectStore(storeName);
                const request = operation(store);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        };

        // =============================================================================
        // VCC Service (Client-Side Implementation)
        // =============================================================================

        const VCCService = {
            async createEvent(eventType, symbol, accountId, payload = {}) {
                const eventId = generateUUIDv7();
                const traceId = payload.trace_id || generateUUIDv7();
                const now = Date.now();
                
                const event = {
                    event_id: eventId,
                    trace_id: traceId,
                    timestamp_int: now * 1000000,
                    timestamp_iso: new Date(now).toISOString(),
                    event_type: eventType,
                    event_type_code: EVENT_TYPES[eventType]?.code || 0,
                    symbol: symbol,
                    venue_id: 'VCC-DEMO',
                    account_id: accountId,
                    payload: payload,
                    anchor_status: 'PENDING',
                    created_at: new Date().toISOString()
                };
                
                // Compute event hash
                const hashInput = {
                    event_id: event.event_id,
                    trace_id: event.trace_id,
                    timestamp_int: event.timestamp_int,
                    event_type: event.event_type,
                    symbol: event.symbol,
                    venue_id: event.venue_id,
                    account_id: event.account_id,
                    payload: event.payload
                };
                event.event_hash = await sha256(hashInput);
                
                await dbOperation('events', 'readwrite', store => store.add(event));
                return event;
            },

            async getEvents(limit = 50) {
                const db = await openDB();
                return new Promise((resolve) => {
                    const tx = db.transaction('events', 'readonly');
                    const store = tx.objectStore('events');
                    const events = [];
                    store.openCursor(null, 'prev').onsuccess = (e) => {
                        const cursor = e.target.result;
                        if (cursor && events.length < limit) {
                            events.push(cursor.value);
                            cursor.continue();
                        } else {
                            resolve(events);
                        }
                    };
                });
            },

            async getPendingEvents() {
                const events = await this.getEvents(500);
                return events.filter(e => e.anchor_status === 'PENDING');
            },

            async createAnchor() {
                const pending = await this.getPendingEvents();
                if (pending.length === 0) return null;

                const eventHashes = pending.map(e => e.event_hash);
                const tree = await buildMerkleTree(eventHashes);
                const merkleRoot = getMerkleRoot(tree);

                const anchorId = generateUUIDv7();
                const now = Date.now();
                
                const anchor = {
                    anchor_id: anchorId,
                    merkle_root: merkleRoot,
                    timestamp_iso: new Date(now).toISOString(),
                    anchor_type: 'CLIENT_DEMO',
                    anchor_identifier: 'browser-indexeddb',
                    event_count: pending.length,
                    event_ids: pending.map(e => e.event_id),
                    status: 'ANCHORED',
                    tree: tree
                };

                await dbOperation('anchors', 'readwrite', store => store.add(anchor));

                // Update events with anchor reference
                const db = await openDB();
                const tx = db.transaction('events', 'readwrite');
                const store = tx.objectStore('events');
                
                for (let i = 0; i < pending.length; i++) {
                    const event = pending[i];
                    event.anchor_status = 'ANCHORED';
                    event.anchor_reference = anchorId;
                    event.merkle_root = merkleRoot;
                    event.merkle_index = i;
                    store.put(event);
                }

                return anchor;
            },

            async getAnchors() {
                const db = await openDB();
                return new Promise((resolve) => {
                    const tx = db.transaction('anchors', 'readonly');
                    const store = tx.objectStore('anchors');
                    const anchors = [];
                    store.openCursor(null, 'prev').onsuccess = (e) => {
                        const cursor = e.target.result;
                        if (cursor) {
                            anchors.push(cursor.value);
                            cursor.continue();
                        } else {
                            resolve(anchors);
                        }
                    };
                });
            },

            async getEventProof(eventId) {
                const event = await dbOperation('events', 'readonly', store => store.get(eventId));
                if (!event || event.anchor_status !== 'ANCHORED') return null;

                const anchor = await dbOperation('anchors', 'readonly', store => store.get(event.anchor_reference));
                if (!anchor || !anchor.tree) return null;

                const auditPath = generateAuditPath(anchor.tree, event.merkle_index);
                
                return {
                    event_id: event.event_id,
                    event_hash: event.event_hash,
                    merkle_root: event.merkle_root,
                    merkle_index: event.merkle_index,
                    audit_path: auditPath,
                    anchor_id: event.anchor_reference
                };
            },

            async verifyCertificate(eventId) {
                const proof = await this.getEventProof(eventId);
                if (!proof) return { valid: false, reason: 'No proof available' };

                const event = await dbOperation('events', 'readonly', store => store.get(eventId));
                const isValid = await verifyMerkleProof(
                    event.event_hash,
                    proof.merkle_root,
                    proof.audit_path,
                    proof.merkle_index
                );

                return {
                    valid: isValid,
                    certificate: {
                        certificate_id: generateUUIDv7(),
                        event_id: eventId,
                        event_hash: event.event_hash,
                        merkle_root: proof.merkle_root,
                        merkle_proof: proof.audit_path,
                        verified_at: new Date().toISOString(),
                        verification_method: 'RFC6962_MERKLE'
                    }
                };
            },

            async clearAll() {
                const db = await openDB();
                const tx = db.transaction(['events', 'anchors'], 'readwrite');
                tx.objectStore('events').clear();
                tx.objectStore('anchors').clear();
            },

            async getStats() {
                const events = await this.getEvents(1000);
                const anchors = await this.getAnchors();
                const pending = events.filter(e => e.anchor_status === 'PENDING').length;
                return {
                    events_count: events.length,
                    anchors_count: anchors.length,
                    pending_count: pending
                };
            }
        };

        // =============================================================================
        // React Components
        // =============================================================================

        const Badge = ({ color, children }) => {
            const colors = {
                blue: 'bg-blue-100 text-blue-800',
                green: 'bg-green-100 text-green-800',
                yellow: 'bg-yellow-100 text-yellow-800',
                red: 'bg-red-100 text-red-800',
                purple: 'bg-purple-100 text-purple-800',
                orange: 'bg-orange-100 text-orange-800',
                gray: 'bg-gray-100 text-gray-800'
            };
            return <span className={`px-2 py-1 rounded text-xs font-medium ${colors[color] || colors.gray}`}>{children}</span>;
        };

        const Card = ({ title, children, className = '' }) => (
            <div className={`bg-white rounded-lg shadow p-4 ${className}`}>
                {title && <h3 className="font-semibold text-gray-700 mb-3">{title}</h3>}
                {children}
            </div>
        );

        const EventRow = ({ event, onVerify }) => (
            <tr className="border-b hover:bg-gray-50">
                <td className="py-2 px-3">
                    <Badge color={EVENT_TYPES[event.event_type]?.color}>{event.event_type}</Badge>
                </td>
                <td className="py-2 px-3 mono text-xs">{event.symbol}</td>
                <td className="py-2 px-3 mono hash-text text-gray-500">{event.event_hash?.slice(0, 16)}...</td>
                <td className="py-2 px-3">
                    <Badge color={event.anchor_status === 'ANCHORED' ? 'green' : 'yellow'}>
                        {event.anchor_status}
                    </Badge>
                </td>
                <td className="py-2 px-3 text-xs text-gray-500">
                    {new Date(event.timestamp_iso).toLocaleTimeString()}
                </td>
                <td className="py-2 px-3">
                    {event.anchor_status === 'ANCHORED' && (
                        <button
                            onClick={() => onVerify(event.event_id)}
                            className="text-xs text-vcc-600 hover:text-vcc-800 font-medium"
                        >
                            Verify
                        </button>
                    )}
                </td>
            </tr>
        );

        const App = () => {
            const [events, setEvents] = useState([]);
            const [anchors, setAnchors] = useState([]);
            const [stats, setStats] = useState({ events_count: 0, anchors_count: 0, pending_count: 0 });
            const [activeTab, setActiveTab] = useState('dashboard');
            const [verifyResult, setVerifyResult] = useState(null);
            const [isLoading, setIsLoading] = useState(false);

            // Form state
            const [formSymbol, setFormSymbol] = useState('XAUUSD');
            const [formAccount, setFormAccount] = useState('demo-trader-001');
            const [formEventType, setFormEventType] = useState('SIG');

            const loadData = useCallback(async () => {
                const [evts, anchs, st] = await Promise.all([
                    VCCService.getEvents(),
                    VCCService.getAnchors(),
                    VCCService.getStats()
                ]);
                setEvents(evts);
                setAnchors(anchs);
                setStats(st);
            }, []);

            useEffect(() => { loadData(); }, [loadData]);

            const handleCreateEvent = async () => {
                setIsLoading(true);
                await VCCService.createEvent(formEventType, formSymbol, formAccount, {
                    price: (2650 + Math.random() * 10).toFixed(2),
                    quantity: '0.1'
                });
                await loadData();
                setIsLoading(false);
            };

            const handleCreateTradeFlow = async () => {
                setIsLoading(true);
                const traceId = generateUUIDv7();
                for (const type of ['SIG', 'ORD', 'ACK', 'EXE', 'CLS']) {
                    await VCCService.createEvent(type, formSymbol, formAccount, {
                        trace_id: traceId,
                        price: (2650 + Math.random() * 10).toFixed(2),
                        quantity: '0.1'
                    });
                    await new Promise(r => setTimeout(r, 100));
                }
                await loadData();
                setIsLoading(false);
            };

            const handleCreateAnchor = async () => {
                setIsLoading(true);
                const anchor = await VCCService.createAnchor();
                if (anchor) {
                    await loadData();
                }
                setIsLoading(false);
            };

            const handleVerify = async (eventId) => {
                const result = await VCCService.verifyCertificate(eventId);
                setVerifyResult(result);
            };

            const handleClearAll = async () => {
                if (confirm('Clear all data? This cannot be undone.')) {
                    await VCCService.clearAll();
                    await loadData();
                    setVerifyResult(null);
                }
            };

            return (
                <div className="min-h-screen">
                    {/* Header */}
                    <header className="bg-gradient-to-r from-vcc-700 to-vcc-800 text-white shadow-lg">
                        <div className="max-w-7xl mx-auto px-4 py-4">
                            <div className="flex items-center justify-between">
                                <div>
                                    <h1 className="text-2xl font-bold">VCC Demo</h1>
                                    <p className="text-vcc-100 text-sm">VeritasChain Cloud - Client-Side Demo</p>
                                </div>
                                <div className="text-right text-sm">
                                    <div className="text-vcc-100">VCP v1.1 Compatible</div>
                                    <div className="mono text-xs text-vcc-200">GitHub Pages Edition</div>
                                </div>
                            </div>
                        </div>
                    </header>

                    {/* Nav */}
                    <nav className="bg-white border-b">
                        <div className="max-w-7xl mx-auto px-4">
                            <div className="flex space-x-4">
                                {['dashboard', 'events', 'anchors', 'verify'].map(tab => (
                                    <button
                                        key={tab}
                                        onClick={() => setActiveTab(tab)}
                                        className={`py-3 px-4 text-sm font-medium border-b-2 ${
                                            activeTab === tab
                                                ? 'border-vcc-500 text-vcc-600'
                                                : 'border-transparent text-gray-500 hover:text-gray-700'
                                        }`}
                                    >
                                        {tab.charAt(0).toUpperCase() + tab.slice(1)}
                                    </button>
                                ))}
                            </div>
                        </div>
                    </nav>

                    {/* Main Content */}
                    <main className="max-w-7xl mx-auto px-4 py-6">
                        {activeTab === 'dashboard' && (
                            <div className="space-y-6">
                                {/* Stats */}
                                <div className="grid grid-cols-3 gap-4">
                                    <Card>
                                        <div className="text-3xl font-bold text-vcc-600">{stats.events_count}</div>
                                        <div className="text-sm text-gray-500">Total Events</div>
                                    </Card>
                                    <Card>
                                        <div className="text-3xl font-bold text-blue-600">{stats.anchors_count}</div>
                                        <div className="text-sm text-gray-500">Anchors Created</div>
                                    </Card>
                                    <Card>
                                        <div className="text-3xl font-bold text-yellow-600">{stats.pending_count}</div>
                                        <div className="text-sm text-gray-500">Pending Events</div>
                                    </Card>
                                </div>

                                {/* Quick Actions */}
                                <Card title="Quick Actions">
                                    <div className="grid grid-cols-2 gap-4">
                                        <div className="space-y-3">
                                            <div className="flex gap-2">
                                                <select
                                                    value={formSymbol}
                                                    onChange={e => setFormSymbol(e.target.value)}
                                                    className="border rounded px-3 py-2 text-sm"
                                                >
                                                    <option>XAUUSD</option>
                                                    <option>EURUSD</option>
                                                    <option>BTCUSD</option>
                                                    <option>USDJPY</option>
                                                </select>
                                                <select
                                                    value={formEventType}
                                                    onChange={e => setFormEventType(e.target.value)}
                                                    className="border rounded px-3 py-2 text-sm"
                                                >
                                                    {Object.keys(EVENT_TYPES).map(t => (
                                                        <option key={t} value={t}>{t}</option>
                                                    ))}
                                                </select>
                                            </div>
                                            <input
                                                value={formAccount}
                                                onChange={e => setFormAccount(e.target.value)}
                                                placeholder="Account ID"
                                                className="border rounded px-3 py-2 text-sm w-full"
                                            />
                                        </div>
                                        <div className="space-y-2">
                                            <button
                                                onClick={handleCreateEvent}
                                                disabled={isLoading}
                                                className="w-full bg-vcc-600 text-white py-2 rounded hover:bg-vcc-700 disabled:opacity-50 text-sm"
                                            >
                                                + Create Single Event
                                            </button>
                                            <button
                                                onClick={handleCreateTradeFlow}
                                                disabled={isLoading}
                                                className="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700 disabled:opacity-50 text-sm"
                                            >
                                                üìä Create Trade Flow (5 events)
                                            </button>
                                            <button
                                                onClick={handleCreateAnchor}
                                                disabled={isLoading || stats.pending_count === 0}
                                                className="w-full bg-purple-600 text-white py-2 rounded hover:bg-purple-700 disabled:opacity-50 text-sm"
                                            >
                                                üîó Create Merkle Anchor ({stats.pending_count} pending)
                                            </button>
                                        </div>
                                    </div>
                                </Card>

                                {/* Recent Events */}
                                <Card title="Recent Events">
                                    {events.length === 0 ? (
                                        <p className="text-gray-500 text-sm">No events yet. Create some above!</p>
                                    ) : (
                                        <div className="overflow-x-auto">
                                            <table className="w-full text-sm">
                                                <thead className="bg-gray-50">
                                                    <tr>
                                                        <th className="text-left py-2 px-3">Type</th>
                                                        <th className="text-left py-2 px-3">Symbol</th>
                                                        <th className="text-left py-2 px-3">Hash</th>
                                                        <th className="text-left py-2 px-3">Status</th>
                                                        <th className="text-left py-2 px-3">Time</th>
                                                        <th className="text-left py-2 px-3">Action</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    {events.slice(0, 10).map(e => (
                                                        <EventRow key={e.event_id} event={e} onVerify={handleVerify} />
                                                    ))}
                                                </tbody>
                                            </table>
                                        </div>
                                    )}
                                </Card>
                            </div>
                        )}

                        {activeTab === 'events' && (
                            <Card title={`All Events (${events.length})`}>
                                <div className="overflow-x-auto max-h-96 overflow-y-auto">
                                    <table className="w-full text-sm">
                                        <thead className="bg-gray-50 sticky top-0">
                                            <tr>
                                                <th className="text-left py-2 px-3">Type</th>
                                                <th className="text-left py-2 px-3">Symbol</th>
                                                <th className="text-left py-2 px-3">Event Hash</th>
                                                <th className="text-left py-2 px-3">Merkle Root</th>
                                                <th className="text-left py-2 px-3">Status</th>
                                                <th className="text-left py-2 px-3">Time</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {events.map(e => (
                                                <tr key={e.event_id} className="border-b hover:bg-gray-50">
                                                    <td className="py-2 px-3"><Badge color={EVENT_TYPES[e.event_type]?.color}>{e.event_type}</Badge></td>
                                                    <td className="py-2 px-3 mono text-xs">{e.symbol}</td>
                                                    <td className="py-2 px-3 mono hash-text text-gray-500">{e.event_hash?.slice(0, 20)}...</td>
                                                    <td className="py-2 px-3 mono hash-text text-gray-500">{e.merkle_root?.slice(0, 20) || '-'}...</td>
                                                    <td className="py-2 px-3"><Badge color={e.anchor_status === 'ANCHORED' ? 'green' : 'yellow'}>{e.anchor_status}</Badge></td>
                                                    <td className="py-2 px-3 text-xs text-gray-500">{new Date(e.timestamp_iso).toLocaleString()}</td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            </Card>
                        )}

                        {activeTab === 'anchors' && (
                            <Card title={`Anchor Records (${anchors.length})`}>
                                {anchors.length === 0 ? (
                                    <p className="text-gray-500 text-sm">No anchors yet. Create events and anchor them!</p>
                                ) : (
                                    <div className="space-y-4">
                                        {anchors.map(a => (
                                            <div key={a.anchor_id} className="border rounded-lg p-4 bg-gray-50">
                                                <div className="flex justify-between items-start">
                                                    <div>
                                                        <div className="font-medium">Anchor #{a.anchor_id.slice(0, 8)}...</div>
                                                        <div className="text-sm text-gray-500">{a.event_count} events</div>
                                                    </div>
                                                    <Badge color="green">{a.status}</Badge>
                                                </div>
                                                <div className="mt-3 space-y-1">
                                                    <div className="text-xs">
                                                        <span className="text-gray-500">Merkle Root: </span>
                                                        <span className="mono text-gray-700">{a.merkle_root}</span>
                                                    </div>
                                                    <div className="text-xs text-gray-500">
                                                        Created: {new Date(a.timestamp_iso).toLocaleString()}
                                                    </div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </Card>
                        )}

                        {activeTab === 'verify' && (
                            <div className="space-y-6">
                                <Card title="Verify Event - 'Verify, Don't Trust'">
                                    <p className="text-sm text-gray-600 mb-4">
                                        Select an anchored event to verify its Merkle proof independently.
                                    </p>
                                    <div className="grid grid-cols-2 gap-4">
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700 mb-2">Select Event</label>
                                            <select
                                                className="w-full border rounded px-3 py-2 text-sm"
                                                onChange={e => e.target.value && handleVerify(e.target.value)}
                                            >
                                                <option value="">-- Select an anchored event --</option>
                                                {events.filter(e => e.anchor_status === 'ANCHORED').map(e => (
                                                    <option key={e.event_id} value={e.event_id}>
                                                        {e.event_type} - {e.symbol} - {e.event_hash?.slice(0, 12)}...
                                                    </option>
                                                ))}
                                            </select>
                                        </div>
                                    </div>
                                </Card>

                                {verifyResult && (
                                    <Card title="Verification Result">
                                        <div className={`p-4 rounded-lg ${verifyResult.valid ? 'bg-green-50 border border-green-200' : 'bg-red-50 border border-red-200'}`}>
                                            <div className="flex items-center gap-2 mb-3">
                                                <span className="text-2xl">{verifyResult.valid ? '‚úÖ' : '‚ùå'}</span>
                                                <span className={`font-bold ${verifyResult.valid ? 'text-green-700' : 'text-red-700'}`}>
                                                    {verifyResult.valid ? 'VERIFICATION PASSED' : 'VERIFICATION FAILED'}
                                                </span>
                                            </div>
                                            {verifyResult.valid && verifyResult.certificate && (
                                                <div className="space-y-2 text-sm">
                                                    <div><strong>Certificate ID:</strong> <span className="mono">{verifyResult.certificate.certificate_id}</span></div>
                                                    <div><strong>Event Hash:</strong> <span className="mono text-xs">{verifyResult.certificate.event_hash}</span></div>
                                                    <div><strong>Merkle Root:</strong> <span className="mono text-xs">{verifyResult.certificate.merkle_root}</span></div>
                                                    <div><strong>Verification Method:</strong> {verifyResult.certificate.verification_method}</div>
                                                    <div><strong>Verified At:</strong> {verifyResult.certificate.verified_at}</div>
                                                    <div className="mt-3">
                                                        <strong>Merkle Proof ({verifyResult.certificate.merkle_proof?.length} steps):</strong>
                                                        <pre className="mt-1 p-2 bg-white rounded text-xs overflow-x-auto">
                                                            {JSON.stringify(verifyResult.certificate.merkle_proof, null, 2)}
                                                        </pre>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    </Card>
                                )}
                            </div>
                        )}
                    </main>

                    {/* Footer */}
                    <footer className="bg-gray-800 text-gray-400 py-6 mt-8">
                        <div className="max-w-7xl mx-auto px-4 text-center text-sm">
                            <p className="mb-2">
                                <strong className="text-white">VCC Demo</strong> - Client-Side Reference Implementation
                            </p>
                            <p className="text-xs mb-2">
                                This demo runs entirely in your browser using IndexedDB. No server required.
                            </p>
                            <p className="text-xs text-gray-500">
                                ‚ö†Ô∏è This is NOT VC-Certified and does not constitute VSO endorsement.
                            </p>
                            <div className="mt-4 flex justify-center gap-4">
                                <a href="https://veritaschain.org" className="text-vcc-400 hover:text-vcc-300">veritaschain.org</a>
                                <a href="https://github.com/veritaschain" className="text-vcc-400 hover:text-vcc-300">GitHub</a>
                                <button onClick={handleClearAll} className="text-red-400 hover:text-red-300">Clear All Data</button>
                            </div>
                            <p className="mt-4 text-xs text-gray-600">
                                VeritasChain Standards Organization (VSO) ‚Ä¢ "Verify, Don't Trust" ‚Ä¢ VCP v1.1
                            </p>
                        </div>
                    </footer>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
