var Et=Object.defineProperty;var Yt=(t,n,s)=>n in t?Et(t,n,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[n]=s;var X=(t,n,s)=>Yt(t,typeof n!="symbol"?n+"":n,s);/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const ft={p:0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedn,n:0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3edn,h:8n,a:0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffecn,d:0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3n,Gx:0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an,Gy:0x6666666666666666666666666666666666666666666666666666666666666658n},{p,n:C,Gx:tt,Gy:nt,a:U,d:V,h:_t}=ft,w=32,K=64,St=(...t)=>{"captureStackTrace"in Error&&typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(...t)},h=(t="")=>{const n=new Error(t);throw St(n,h),n},Rt=t=>typeof t=="bigint",Kt=t=>typeof t=="string",vt=t=>t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array",x=(t,n,s="")=>{const e=vt(t),f=t==null?void 0:t.length,c=n!==void 0;if(!e||c&&f!==n){const r=s&&`"${s}" `,a=c?` of length ${n}`:"",i=e?`length=${f}`:`type=${typeof t}`;h(r+"expected Uint8Array"+a+", got "+i)}return t},F=t=>new Uint8Array(t),rt=t=>Uint8Array.from(t),it=(t,n)=>t.toString(16).padStart(n,"0"),N=t=>Array.from(x(t)).map(n=>it(n,2)).join(""),g={_0:48,_9:57,A:65,F:70,a:97,f:102},st=t=>{if(t>=g._0&&t<=g._9)return t-g._0;if(t>=g.A&&t<=g.F)return t-(g.A-10);if(t>=g.a&&t<=g.f)return t-(g.a-10)},P=t=>{const n="hex invalid";if(!Kt(t))return h(n);const s=t.length,e=s/2;if(s%2)return h(n);const f=F(e);for(let c=0,r=0;c<e;c++,r+=2){const a=st(t.charCodeAt(r)),i=st(t.charCodeAt(r+1));if(a===void 0||i===void 0)return h(n);f[c]=a*16+i}return f},at=()=>globalThis==null?void 0:globalThis.crypto,Ct=()=>{var t;return((t=at())==null?void 0:t.subtle)??h("crypto.subtle must be defined, consider polyfill")},Y=(...t)=>{const n=F(t.reduce((e,f)=>e+x(f).length,0));let s=0;return t.forEach(e=>{n.set(e,s),s+=e.length}),n},lt=(t=w)=>at().getRandomValues(F(t)),L=BigInt,E=(t,n,s,e="bad number: out of range")=>Rt(t)&&n<=t&&t<s?t:h(e),o=(t,n=p)=>{const s=t%n;return s>=0n?s:n+s},ut=t=>o(t,C),dt=(t,n)=>{(t===0n||n<=0n)&&h("no inverse n="+t+" mod="+n);let s=o(t,n),e=n,f=0n,c=1n;for(;s!==0n;){const r=e/s,a=e%s,i=f-c*r;e=s,s=a,f=c,c=i}return e===1n?o(f,n):h("no inverse")},yt=t=>{const n=At[t];return typeof n!="function"&&h("hashes."+t+" not set"),n},Ht=t=>yt("sha512")(t),q=t=>t instanceof Z?t:h("Point expected"),G=2n**256n,A=class A{constructor(n,s,e,f){X(this,"X");X(this,"Y");X(this,"Z");X(this,"T");const c=G;this.X=E(n,0n,c),this.Y=E(s,0n,c),this.Z=E(e,1n,c),this.T=E(f,0n,c),Object.freeze(this)}static CURVE(){return ft}static fromAffine(n){return new A(n.x,n.y,1n,o(n.x*n.y))}static fromBytes(n,s=!1){const e=V,f=rt(x(n,w)),c=n[31];f[31]=c&-129;const r=z(f);E(r,0n,s?G:p);const i=o(r*r),l=o(i-1n),u=o(e*i+1n);let{isValid:d,value:y}=Ot(l,u);d||h("bad point: y not sqrt");const b=(y&1n)===1n,m=(c&128)!==0;return!s&&y===0n&&m&&h("bad point: x==0, isLastByteOdd"),m!==b&&(y=o(-y)),new A(y,r,1n,o(y*r))}static fromHex(n,s){return A.fromBytes(P(n),s)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}assertValidity(){const n=U,s=V,e=this;if(e.is0())return h("bad point: ZERO");const{X:f,Y:c,Z:r,T:a}=e,i=o(f*f),l=o(c*c),u=o(r*r),d=o(u*u),y=o(i*n),b=o(u*o(y+l)),m=o(d+o(s*o(i*l)));if(b!==m)return h("bad point: equation left != right (1)");const _=o(f*c),S=o(r*a);return _!==S?h("bad point: equation left != right (2)"):this}equals(n){const{X:s,Y:e,Z:f}=this,{X:c,Y:r,Z:a}=q(n),i=o(s*a),l=o(c*f),u=o(e*a),d=o(r*f);return i===l&&u===d}is0(){return this.equals(R)}negate(){return new A(o(-this.X),this.Y,this.Z,o(-this.T))}double(){const{X:n,Y:s,Z:e}=this,f=U,c=o(n*n),r=o(s*s),a=o(2n*o(e*e)),i=o(f*c),l=n+s,u=o(o(l*l)-c-r),d=i+r,y=d-a,b=i-r,m=o(u*y),_=o(d*b),S=o(u*b),v=o(y*d);return new A(m,_,v,S)}add(n){const{X:s,Y:e,Z:f,T:c}=this,{X:r,Y:a,Z:i,T:l}=q(n),u=U,d=V,y=o(s*r),b=o(e*a),m=o(c*d*l),_=o(f*i),S=o((s+e)*(r+a)-y-b),v=o(_-m),J=o(_+m),Q=o(b-u*y),gt=o(S*v),Zt=o(J*Q),Tt=o(S*Q),Xt=o(v*J);return new A(gt,Zt,Xt,Tt)}subtract(n){return this.add(q(n).negate())}multiply(n,s=!0){if(!s&&(n===0n||this.is0()))return R;if(E(n,1n,C),n===1n)return this;if(this.equals(T))return qt(n).p;let e=R,f=T;for(let c=this;n>0n;c=c.double(),n>>=1n)n&1n?e=e.add(c):s&&(f=f.add(c));return e}multiplyUnsafe(n){return this.multiply(n,!1)}toAffine(){const{X:n,Y:s,Z:e}=this;if(this.equals(R))return{x:0n,y:1n};const f=dt(e,p);o(e*f)!==1n&&h("invalid inverse");const c=o(n*f),r=o(s*f);return{x:c,y:r}}toBytes(){const{x:n,y:s}=this.assertValidity().toAffine(),e=ht(s);return e[31]|=n&1n?128:0,e}toHex(){return N(this.toBytes())}clearCofactor(){return this.multiply(L(_t),!1)}isSmallOrder(){return this.clearCofactor().is0()}isTorsionFree(){let n=this.multiply(C/2n,!1).double();return C%2n&&(n=n.add(this)),n.is0()}};X(A,"BASE"),X(A,"ZERO");let Z=A;const T=new Z(tt,nt,1n,o(tt*nt)),R=new Z(0n,1n,1n,0n);Z.BASE=T;Z.ZERO=R;const ht=t=>P(it(E(t,0n,G),K)).reverse(),z=t=>L("0x"+N(rt(x(t)).reverse())),B=(t,n)=>{let s=t;for(;n-- >0n;)s*=s,s%=p;return s},Lt=t=>{const s=t*t%p*t%p,e=B(s,2n)*s%p,f=B(e,1n)*t%p,c=B(f,5n)*f%p,r=B(c,10n)*c%p,a=B(r,20n)*r%p,i=B(a,40n)*a%p,l=B(i,80n)*i%p,u=B(l,80n)*i%p,d=B(u,10n)*c%p;return{pow_p_5_8:B(d,2n)*t%p,b2:s}},et=0x2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0n,Ot=(t,n)=>{const s=o(n*n*n),e=o(s*s*n),f=Lt(t*e).pow_p_5_8;let c=o(t*s*f);const r=o(n*c*c),a=c,i=o(c*et),l=r===t,u=r===o(-t),d=r===o(-t*et);return l&&(c=a),(u||d)&&(c=i),(o(c)&1n)===1n&&(c=o(-c)),{isValid:l||u,value:c}},O=t=>ut(z(t)),M=(...t)=>At.sha512Async(Y(...t)),$=(...t)=>yt("sha512")(Y(...t)),pt=t=>{const n=t.slice(0,w);n[0]&=248,n[31]&=127,n[31]|=64;const s=t.slice(w,K),e=O(n),f=T.multiply(e),c=f.toBytes();return{head:n,prefix:s,scalar:e,point:f,pointBytes:c}},j=t=>M(x(t,w)).then(pt),D=t=>pt($(x(t,w))),kt=t=>j(t).then(n=>n.pointBytes),Ft=t=>D(t).pointBytes,bt=t=>M(t.hashable).then(t.finish),xt=t=>t.finish($(t.hashable)),mt=(t,n,s)=>{const{pointBytes:e,scalar:f}=t,c=O(n),r=T.multiply(c).toBytes();return{hashable:Y(r,e,s),finish:l=>{const u=ut(c+O(l)*f);return x(Y(r,ht(u)),K)}}},Nt=async(t,n)=>{const s=x(t),e=await j(n),f=await M(e.prefix,s);return bt(mt(e,f,s))},Pt=(t,n)=>{const s=x(t),e=D(n),f=$(e.prefix,s);return xt(mt(e,f,s))},I={zip215:!0},Bt=(t,n,s,e=I)=>{t=x(t,K),n=x(n),s=x(s,w);const{zip215:f}=e;let c,r,a,i,l=Uint8Array.of();try{c=Z.fromBytes(s,f),r=Z.fromBytes(t.slice(0,w),f),a=z(t.slice(w,K)),i=T.multiply(a,!1),l=Y(r.toBytes(),c.toBytes(),n)}catch{}return{hashable:l,finish:d=>{if(i==null||!f&&c.isSmallOrder())return!1;const y=O(d);return r.add(c.multiply(y,!1)).add(i.negate()).clearCofactor().is0()}}},zt=async(t,n,s,e=I)=>bt(Bt(t,n,s,e)),Mt=(t,n,s,e=I)=>xt(Bt(t,n,s,e)),$t={bytesToHex:N,hexToBytes:P,concatBytes:Y,mod:o,invert:dt,randomBytes:lt},At={sha512Async:async t=>{const n=Ct(),s=Y(t);return F(await n.digest("SHA-512",s.buffer))},sha512:void 0},W=(t=lt(w))=>t,jt=t=>{const n=W(t),s=Ft(n);return{secretKey:n,publicKey:s}},Dt=async t=>{const n=W(t),s=await kt(n);return{secretKey:n,publicKey:s}},It={getExtendedPublicKeyAsync:j,getExtendedPublicKey:D,randomSecretKey:W},k=8,Ut=256,wt=Math.ceil(Ut/k)+1,H=2**(k-1),Vt=()=>{const t=[];let n=T,s=n;for(let e=0;e<wt;e++){s=n,t.push(s);for(let f=1;f<H;f++)s=s.add(n),t.push(s);n=s.double()}return t};let ot;const ct=(t,n)=>{const s=n.negate();return t?s:n},qt=t=>{const n=ot||(ot=Vt());let s=R,e=T;const f=2**k,c=f,r=L(f-1),a=L(k);for(let i=0;i<wt;i++){let l=Number(t&r);t>>=a,l>H&&(l-=c,t+=1n);const u=i*H,d=u,y=u+Math.abs(l)-1,b=i%2!==0,m=l<0;l===0?e=e.add(ct(b,n[d])):s=s.add(ct(m,n[y]))}return t!==0n&&h("invalid wnaf"),{p:s,f:e}};export{Z as Point,$t as etc,Ft as getPublicKey,kt as getPublicKeyAsync,Ht as hash,At as hashes,jt as keygen,Dt as keygenAsync,Pt as sign,Nt as signAsync,It as utils,Mt as verify,zt as verifyAsync};
